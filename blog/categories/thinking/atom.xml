<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Thinking | xautjzd]]></title>
  <link href="http://xautjzd.github.io/blog/categories/thinking/atom.xml" rel="self"/>
  <link href="http://xautjzd.github.io/"/>
  <updated>2013-09-26T16:06:30+08:00</updated>
  <id>http://xautjzd.github.io/</id>
  <author>
    <name><![CDATA[xautjzd]]></name>
    <email><![CDATA[xautjzd@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ASP.NET MVC Json()处理大数据异常解决方法]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/26/json-serializer-maxjsonlength-exception/"/>
    <updated>2013-09-26T15:15:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/26/json-serializer-maxjsonlength-exception</id>
    <content type="html"><![CDATA[<p>近几天一直忙于windows下的项目，rails的学习暂时搁置了，所以也有好几天没有用fedora了，博客大致也有一周没有更新。此博客本想只记录一些Linux平台下的相关操作，但这两天碰到的问题很棘手，虽最终得以解决，但不忍就此翻篇，想将解决之法记录下来，以避免今后再次碰到此类问题又得重头再寻求解决方案，同时也分享出来，避免其他人碰到此问题时多走弯路。所以便予以记录。下面切入正题：</p>

<p>先对项目做个简单介绍：</p>

<!-- more -->


<p>整个项目采用微软的ASP.NET MVC3进行开发，前端显示采用EasyUI框架，图表的显示用的是Highcharts，主要进行曲线图的绘制，这样比较形象地描绘出变化的趋势。由于数据量比较大(大于1000，000条记录)，而highcharts接受的数据类型为json格式，所以controller从数据库中取出的数据需要先格式化成json,然后再传到前端。平时一直采用MVC的Json()将数据序列化成json格式，但是由于此次数据量较大，所以曲线不显示，所以一直以为是由于数据量较大，highcharts插件不支持100w级数据，后来听人说highcharts本身是支持100w级数据的。最后采用firebug调试才发现出现了错误：“使用JSON JavaScriptSerializer进行序列化或反序列化时出错。字符串的长度超过了为maxJsonLength属性设置的值”,网上也找了不少解决方案，几乎无一例外说的是在web.config的<configuration>节点下添加：</p>

<pre><code>&lt;system.web.extensions&gt;
    &lt;scripting&gt;
        &lt;webServices&gt;
            &lt;jsonSerialization maxJsonLength="1024000000" /&gt;
        &lt;/webServices&gt;
    &lt;/scripting&gt;
&lt;/system.web.extensions&gt;
</code></pre>

<p>试过后发现曲线还是没出来，最后拿出杀手锏：谷歌翻译成英文，再次搜索，最后终于在stackoverflow上找到解决之法：</p>

<pre><code>public ActionResult GetLargeJsonResult()
{
  return new ContentResult
    {
        Content = new JavaScriptSerializer { MaxJsonLength = Int32.MaxValue }.Serialize(myBigdata),
        ContentType = "application/json"
    };
}
</code></pre>

<p>具体网址：<a href="http://stackoverflow.com/questions/4155014/json-asp-net-mvc-maxjsonlength-exception">http://stackoverflow.com/questions/4155014/json-asp-net-mvc-maxjsonlength-exception</a></p>

<p>这里不得不大赞StackOverflow,好多问题都是在上面找到solution,而且上面还有非常多的好心人士热心细致的回答问题，我提了好几个问题都最终得到所谓Geek的帮助并得以解决。这里，我只想说声：谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cookies vs Sessions]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/09/cookies-vs-sessions/"/>
    <updated>2013-09-09T10:37:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/09/cookies-vs-sessions</id>
    <content type="html"><![CDATA[<p>Http是无状态的协议，客户端给服务器发送请求，服务端响应客户端的请求，会话结束。这样两次会话间不便没有任何关联。但有时候需要在会话间进行信息共享，如：购物车，保存用户名与密码等。为此，cookie与session便诞生了,它们的存在就是为了弥补http协议无状态的缺陷。</p>

<p>cookie与session最大的不同是：cookie保存在用户的浏览器中，而session则保留在服务端。正是这种不同决定了它们的不用使用场合。</p>

<h2>Cookie</h2>

<hr />

<p>cookie机制是通过扩展http协议来实现的。服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。其实纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器端。</p>

<p>cookie主要内容包括：Name,Content,Path,Domain,Expires(过期时间)等。Domain与Path一起构成cookie的作用范围。</p>

<p>若不设置Expires,则默认的cookie生命周期为浏览器会话期间，一旦浏览器关闭，cookie则会被清理掉，这种生命周期为浏览器会话期的cookie被成为会话cookie。会话cookie存储在内存中而不是在硬盘上。</p>

<p>若设置了Expires,浏览器则会把生成的cookie保存在硬盘上，即使浏览器关闭后再打开，cookie依然有效，直至超过设置的expires。</p>

<p>另外，session大小有限制，一旦浏览器禁用cookie，则采用cookie的购物网站便不能进行购物，所以这时候得用session了。</p>

<!-- more -->


<h2>Session</h2>

<hr />

<p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>

<p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p>

<p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。</p>

<h2>Cookie与Session区别</h2>

<hr />

<ol>
<li>cookie存储在客户端的浏览器中，而session则存储在服务器上。</li>
<li>cookie不安全，可以通过分析本地cookie并进行cookie欺骗，而session则相对比较安全。</li>
<li>session会在服务器上保存一段时间，但当访问量增大，会占用服务器的存储空间，影响服务器的性能，如考虑到减轻服务器的性能，则可以选择cookie。</li>
<li>单个cookie保存的数据不会超过4k。</li>
</ol>


<p>所以，一般将登陆等重要信息采用session保存，而其他信息则采用cookie。</p>

<h2>参考资料</h2>

<hr />

<ol>
<li><a href="http://en.wikipedia.org/wiki/Session_">http://en.wikipedia.org/wiki/Session_</a>(computer_science)</li>
<li><a href="http://en.wikipedia.org/wiki/HTTP_cookie#cite_note-1">http://en.wikipedia.org/wiki/HTTP_cookie#cite_note-1</a></li>
<li><a href="http://www.cnblogs.com/shiyangxt/articles/1305506.html">http://www.cnblogs.com/shiyangxt/articles/1305506.html</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查看网站所用Web服务器类型]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/04/lookup-webserver/"/>
    <updated>2013-09-04T16:43:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/04/lookup-webserver</id>
    <content type="html"><![CDATA[<p>学习Rails的Layout过程中，其中有提到curl，所以便简单的看了下curl的功能。虽说以前学习Shell的过程中也看到过curl,不过没怎么用过，只知道和wget功能类似，只是wget是将请求的web资源下载到本地，而curl则是在shell中显示，至于有什么其他功能也便不清楚。但是今天发现curl其实还可以用来查看website所用的web服务器类型，通过<code>curl -I url-you-want-to-lookup</code>命令查看即可。以下是我查看ruby-china的一个截图：
<img src="http://pic.yupoo.com/xautjzd/D8xXpw6z/medish.jpg" alt="" /></p>

<p>从中可以发现ruby-china采用的是nginx服务器。至于curl其他的功能慢慢再发掘吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[账号注册通过邮箱激活]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/03/activate-user-via-email/"/>
    <updated>2013-09-03T21:48:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/03/activate-user-via-email</id>
    <content type="html"><![CDATA[<h3>邮箱激活目的</h3>

<p>防止用户注册时所填写的信息为虚假信息</p>

<h3>邮箱激活的原理</h3>

<p>用户注册时，根据用户名、Email及注册时间(精确到ms)等信息通过特定的算法(如:MD5、SHA，最好不可逆)生成相应的信息摘要(也称消息摘要)作为注册的激活码，保存到数据库当中，并且将其作为url的参数，将带有激活码的url链接发送到用户注册的Email中。</p>

<p>只有当用户进入邮箱中并点击该链接后，通过url中的激活码找出数据库中匹配的用户，并将此账号设为“已激活”的状态。</p>

<p><strong>注：此过程没有考虑激活码过期问题，同时信息摘要也可以通过随机数来表示，不一定非要通过用户名等信息生成</strong></p>

<p>Rails代码参考：</p>

<p><a href="http://stackoverflow.com/questions/12805523/activate-user-via-email-in-rails">http://stackoverflow.com/questions/12805523/activate-user-via-email-in-rails</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux活动发起]]></title>
    <link href="http://xautjzd.github.io/blog/2013/08/20/linux-activity-sponsoring/"/>
    <updated>2013-08-20T19:04:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/08/20/linux-activity-sponsoring</id>
    <content type="html"><![CDATA[<p>独乐乐不如众乐乐，独自一人埋头苦学不如一群兴趣相投之人的一起交流。记得以前大一大二时，希望能有一个领路人领着自己学习，帮自己找准学习的方向，毕竟当时太年轻，太多东西不了解，所以不知道软件这行业该学习什么，哪些东西比较有兴趣，一切源于自己接触的太少，身边也没有可交流之人。再加上学校大一大二和大三大四分隔新旧两校区，交流就更少。</p>

<p>正是因为自己的这些经历，然后再加上近来参加西安的rubyist party，促使了我组建Linux小组并且定期举办活动的冲动。一个人的埋头苦学，所见所闻永远局限在某个狭小的空间，只有走出去，与他们交流才能拓宽自己的知识面，提升自己的认知度，也算是多了一些朋友，多了一些交流。正所谓话不投机半句多，与自己志不同道不和的人交流真是有点对牛弹琴的感觉。所以要交流得找兴趣相投志同道合之人。</p>

<p>打算成立的小组规模大致10人左右，无需太多，也不希望有滥竽充数的现象。所以希望小组成员能满足以下条件：</p>

<ul>
<li>对软件感兴趣</li>
<li>熟悉Linux(基本操作一般没问题)</li>
<li>Vim | Emacs</li>
</ul>


<p>具备以下更佳：</p>

<ul>
<li>Git</li>
<li>Ruby/Python/Lisp/Scala/Prolog</li>
<li>个人博客</li>
</ul>


<p>初期打算:</p>

<ul>
<li>每周一次Party（主要技术交流）</li>
</ul>


<p>有兴趣的学习请联系我，联系方式：</p>

<ul>
<li>新郎微薄：xautjzd</li>
</ul>


<p>其他联系方式见我的<a href="http://xautjzd.github.io/blog/aboutme">About</a></p>
]]></content>
  </entry>
  
</feed>
