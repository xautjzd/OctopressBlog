<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | xautjzd]]></title>
  <link href="http://xautjzd.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://xautjzd.github.io/"/>
  <updated>2013-10-01T23:52:23+08:00</updated>
  <id>http://xautjzd.github.io/</id>
  <author>
    <name><![CDATA[xautjzd]]></name>
    <email><![CDATA[xautjzd@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[计算机启动过程]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/26/boot-process/"/>
    <updated>2013-09-26T18:48:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/26/boot-process</id>
    <content type="html"><![CDATA[<p>计算机启动过程的详细介绍请参考阮一峰老师的两篇博文：</p>

<ol>
<li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">http://www.ruanyifeng.com/blog/2013/02/booting.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html</a></li>
</ol>


<p>写的非常通俗易懂，真的很佩服阮老师的文笔，有时候自己写的博客自己都有点目不忍视，更何况别人呢。要达到这样的水平真的还有好长的路要走。加油吧</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim常用快捷键总结]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/18/vim-shortcut-maps/"/>
    <updated>2013-09-18T19:55:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/18/vim-shortcut-maps</id>
    <content type="html"><![CDATA[<p>Vim的学习之路真的很长，永远有记不完的命令，永远会突然冒出一个新插件。不过我总算从Vim的荆棘中一路走过来了，现在真的是苦尽甘来，时刻体会它带给我的喜悦和惊奇。下面对我所学习所了解到的常用命令做一个基本总结：</p>

<h3>Normal mode:</h3>

<p><code>&gt;&gt;</code> indent current line</p>

<p><code>n&gt;&gt;</code> indent the next n line</p>

<p><code>.</code> repeat last command</p>

<p><code>m,n&gt;&gt;</code> indent from m to n line</p>

<p><code>==</code> autoindent current line</p>

<p><code>n==</code> autoindent the next n line</p>

<p><code>gg=G</code> autoindent the whole file</p>

<!--more-->


<p><code>=i{</code> reindents &lsquo;inner block&rsquo;(inside the braces)</p>

<p><code>=a{</code> reindents &ldquo;around block&rdquo;(including the braces)</p>

<p><code>=2a{</code> reindents 2 blocks(this block and containing block)</p>

<p>instead of &ldquo;{&rdquo;, also can use &ldquo;}&rdquo; or &ldquo;B&rdquo;.<code>=aB</code> equals <code>=a{</code></p>

<p><code>&gt;i{</code> increase indent for inner block</p>

<p><code>&lt;i}</code> decrease indent for inner block</p>

<p><code>&gt;a{</code> increase indent for around block(including the brace)</p>

<p><code>&lt;a}</code> decrease indent for around block</p>

<p>With the cursor on <code>{</code> or <code>}</code></p>

<p><code>=%</code> autoindent the block(including matching brace)</p>

<p><code>&lt;%</code> or <code>&gt;%</code> indents or unindents the block</p>

<h3>Insert mode:</h3>

<p><code>&lt;c+t&gt;</code> indent the current line</p>

<p><code>&lt;c+d&gt;</code> reindent the current line</p>

<h3>Surroud plugin</h3>

<p>以下是一些surround插件的功能：</p>

<pre><code>{
    xxx
    xxx
}
</code></pre>

<p>normal模式下输入：dS{,结果变为:</p>

<pre><code>xxx
xxx

"hello world"
</code></pre>

<p>cS"&lsquo;之后，结果变为：</p>

<pre><code>'hello world'

&lt;div&gt;hello&lt;/div&gt;
</code></pre>

<p>通过cSt然后输入<code>&lt;p&gt;</code>,结果变为：</p>

<pre><code>&lt;p&gt;hello&lt;/p&gt;
</code></pre>

<p>当然也可以选进入visual模式，然后S"，便给选中的文本包含"&ldquo;。</p>

<p>以上命令主要是关于缩进和对齐的一个总结，关于surround插件做的总结也只是将所学列出，学过之后才感觉几乎毫无用处，所以不学也罢。其他的一些常用功能抽空再做总结。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建Git服务器]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/17/build-git-remote-repository/"/>
    <updated>2013-09-17T10:54:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/17/build-git-remote-repository</id>
    <content type="html"><![CDATA[<p>从开始用Git到现在也已经有一年时间了，但一直都在本地开发，用于管理本地的代码，没有进行多人协作开发，所以也没有必要搭建一个Git服务器。</p>

<p>但就在昨晚，我在教研室给大家介绍Git工具时，感觉大家对这个工具貌似没有太大的热情，猜其原因，可能是因为大家对这个工具过于陌生，而我又讲的太过细节，所以他们可能听得有点烦。但是只有试过之后才能感觉其方便之处，我也希望教研室的同学都能掌握它，所以便决定在教研室搭建一个Git服务器，供大家使用，也思索着今后的项目都用git来进行管理。毕竟现在教研室只有我一人使用git,其他同学都用svn,甚至不用(其实用svn的同学不超过3个)，开发项目也难以统一，而我个人在使用过git后又不想转向svn，同时也非常希望身边的同学也能去使用git这么一个优秀工具，所以只能忽悠他们转向git了。不过经昨晚一役，证明了我忽悠人的本领完全不到家，看来今后得好好练练了。前奏有点过于冗长，下面进入正题吧。</p>

<!-- more -->


<p>由于此次git服务器是搭建在Linux平台，所以首先得有一台安装过Linux的pc,不过幸好我有一台台式机安装了Fedora,这样第一个要素就搞定了。接下来我选择的是ssh来作为git url的协议，因为ssh协议安全方便。所以服务器上还得安装ssh。比较好用的当属openssh了，我此前一直在fedora上用git管理我个人的代码，并且托管在GitHub上，所以这个环节也省了。没有安装的可以试试openssh，具体安装步骤问Google。</p>

<p>当然为了每次对远程库进行操作而不用输入用户名和密码，就需要将本地的公钥拷贝到服务器上对应的文件里，具体步骤如下：</p>

<h3>服务器</h3>

<p>首先为了操作方便安全，需要在服务器上创建一个名为git的用户：</p>

<pre><code>#useradd git
</code></pre>

<p>接着进入到/home/git目录下新建一个.ssh目录,并且需要将.ssh目录group和others的写权限去掉，改为700|744|755皆可,否则ssh远程连接服务器还需要输入密码：</p>

<pre><code>git$ mkdir ~/.ssh
git$ chmod 744 .ssh
</code></pre>

<p>服务端工作暂时完成</p>

<h3>客户端</h3>

<p>进入~/.ssh/目录，生成公钥和密钥：</p>

<pre><code>$ ssh-keygen
</code></pre>

<p>然后一直回车，完成后会发现在~/.ssh目录下多了id_rsa和id_rsa.pub文件，然后将客户端生成的id_rsa.pub公钥拷贝到服务器上：</p>

<pre><code>$scp id_rsa.pub git@your_server_ip/~/.ssh/
</code></pre>

<p>以上操作在~/.ssh目录下进行，git为刚才服务器创建的用户(当然用户名可为其他用户名，只要和服务器对应便可)。此操作完成便会发现服务器上的~/.ssh/目录下多了一个id_rsa.pub文件。</p>

<p>现在转到服务器，将服务器上的~/.ssh目录下的id_rsa.pub文件改为authorized_keys。再重启sshd服务，使配置生效即可。</p>

<p>既然提到服务的开启与关闭，顺带将其操作列出来：</p>

<pre><code>#systemctl start sshd.service     #启动服务
#systemctl stop sshd.service      #关闭服务
#systemctl enable sshd.servie     #使服务开机便自动运行
#systemctl is-enabled sshd.servie #查看服务是否开机启动
#systemctl disable sshd.service   #取消开机自动运行
#systemctl status sshd.service    #查看服务运行状态
#systemctl restart sshd.service   #重启服务
#systemctl reload sshd.service    #重新加载服务配置文件
#systemctl --failed               #显示启动失败的服务
</code></pre>

<h2>SSH无密钥验证原理</h2>

<p>客户端用ssh发起一个ssh连接时，服务端生成一个随机数并用客户端的公钥(保存在authorized_keys中)进行加密，然后发给客户端，客户端用私钥进行解密，并将解密后的数发送给服务端，服务端确认无误后便允许客户端进行连接了。</p>

<p>以上过程的前提是客户端已将公钥保存在服务端的authorized_keys文件中。</p>

<h2>搭建Git服务器</h2>

<p>新建一个文件夹，用来作为Git服务器Repository,然后初始化。如我远程repository文件夹为/home/git/demo/,操作如下：</p>

<pre><code>$mkdir demo    #in /home/git/ directory
$cd ~/demo/
$git init
</code></pre>

<p>然后在客户端添加此远程库，便可进行代码的push和pull了。</p>

<pre><code>$git remote add origin git@your_server_ip:~/demo
#after git add &amp; git commit,run git push
$ git push origin master
</code></pre>

<p>这样就把要管理的代码提交到Git服务器，并用Git来进行管理了。</p>

<p>至此，工作基本完成，后续还有好多东西需要研究，如代码的审查机制等，当然这个功能目前还用不到，但是想了解一下审查机制如何建立，后续再学习吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBox安装ArchLinux系统]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/12/installing-archlinux-in-virtualbox/"/>
    <updated>2013-09-12T22:36:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/12/installing-archlinux-in-virtualbox</id>
    <content type="html"><![CDATA[<p>都说ArchLinux很适合折腾，趁今天有时间，就试着安装了一把，不过看ArchLinux的Beginners&rsquo;s Guide，照着其步骤来，结果还是看的云里雾里，看的人头大。便直接上Youtube上找了一个视频，顿时豁然开朗。安装概览如下：</p>

<h2>ArchLinux Install</h2>

<ol>
<li>分区</li>
<li>格式化分区</li>
<li>挂载分区</li>
<li>更改安装镜像</li>
<li>安装基本系统</li>
<li>生成fstab</li>
<li>Chroot到新系统</li>
<li>配置系统</li>
<li>开启网络服务</li>
<li>创建初始化ramdisk环境</li>
<li>设置root密码</li>
<li>安装配置bootloader</li>
<li>卸载分区并重启系统</li>
<li>安装图形用户界面</li>
</ol>


<p>详细步骤如下：</p>

<h3>1. 分区</h3>

<p>虚拟机挂在iso镜像后，然后启动系统，进入后默认进入root提示符，然后输入：</p>

<pre><code>root#cfdisk
</code></pre>

<p>进行分区，一般分三个即可。最后分区结果如下：</p>

<pre><code>dev/sda1 / 8G
dev/sda2 /swap 1G(在空间最后)
dev/sda3 /home 4G
</code></pre>

<p>每个人的分区情况都可能不同，具体依照自己的分区来决定，以下操作都是根据我的分区来进行。</p>

<!-- more -->


<h3>2. 格式化分区</h3>

<p>执行如下命令格式化分区</p>

<pre><code>#mkfs.ext4 /dev/sda1
#mkfs.ext4 /dev/sda3
#mkswap /dev/sda2
#swapon /dev/sda2  #enable swap partion
</code></pre>

<h3>3. 挂载分区</h3>

<pre><code>#mount /dev/sda1 /mnt #mount root partion
#mkdir /mnt/home
#mount /dev/sda3 /mnt/home  #mount home partion
</code></pre>

<h3>4. 更改安装镜像</h3>

<p>镜像列表优先级从上往下，所以为了软件更新的速度，最好将国内的mirror放到最上面。我添加的源及方法如下：</p>

<pre><code>#vi /etc/pacman.d/mirrorlist

Server = http://mirrors.163.com/archlinux/$repo/os/$arch
Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch
Server = http://mirrors.sohu.com/archlinux/$repo/os/$arch
Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch
Server = http://ftp.tku.edu.tw/Linux/ArchLinux/$repo/os/$arch
...
</code></pre>

<h3>5. 安装基本系统</h3>

<p>通过pacstrap脚本安装基本系统，方法如下：</p>

<pre><code>#pacstrap base base-devel
</code></pre>

<h3>6. 生成fstab</h3>

<p>通过下面的命令来生成fstab：</p>

<pre><code>#genfstab /mnt &gt;&gt; /mnt/etc/fstab
</code></pre>

<h3>7. Chroot到新系统</h3>

<p>通过以下命令chroot到新安装的系统:</p>

<pre><code>#arch-chroot /mnt
</code></pre>

<p>使用chroot后，系统的目录结构将以指定的位置作为"/&ldquo;目录</p>

<h3>8. 配置系统</h3>

<p>系统的配置主要有locale和时区的配置。</p>

<ul>
<li>Locale</li>
</ul>


<p>配置方法如下：</p>

<pre><code>#vi /etc/locale.gen
#locale-gen
</code></pre>

<ul>
<li>配置时区</li>
</ul>


<p>系统默认是utc时区，我们需要换到utc+8时区，方法如下：</p>

<pre><code>#ln s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>

<h3>9. 开启网络服务</h3>

<p>先通过ping命令查看网络是否正常，如果不能上网，则需要配置，方法有两种：1.dhcp  2.static ip。我用的是dhcp，所以只需要开启dhcp服务,方法如下：</p>

<pre><code>#dhcpcd interface_name
</code></pre>

<p>其中interface_name可以通过ifconfig或者ip addr查询。默认在虚拟机中便可上网，所以无需配置。但是安装完成重启系统后便不能上网，原因是dhcp服务没启动。(这是我所碰到的情况)</p>

<h3>10. 创建初始化ramdisk环境</h3>

<p>ramdisk是通过软件将一部分内存(RAM)来模拟一个硬盘，提高访问速度。当然这只是针对内存过剩的情况下才使用，一般完全没有必要。如果您觉得内存完全用不完，为了有效的利用，可以创建ramdisk，毕竟RAM的访问速度非常快，差不多是固态硬盘的30倍。创建ramdisk的方法如下：</p>

<pre><code>    #mkinitcpio -p linux
</code></pre>

<p>通过<code>#vi /etc/mkinitcpio.conf</code>来查看相应的配置信息。</p>

<h3>11. 设置root密码</h3>

<p>设置密码的命令都通用:</p>

<pre><code>#passwd
</code></pre>

<p>然后输入符合要求的密码即可。当然平时操作尽量不要用root,所以为此可以新建一个用户。</p>

<h3>12. 安装配置bootloader</h3>

<p>根据主板BIOS类型不同，安装和配置bootloader的方式也不同。
大致有两种类型：</p>

<ol>
<li>传统的BIOS

<ul>
<li>Syslinux</li>
<li>Grub</li>
</ul>
</li>
<li>UEFI BIOS

<ul>
<li>EFISTUB</li>
<li>Gummiboot</li>
<li>Grub</li>
</ul>
</li>
</ol>


<p>我的主板是传统BIOS类型，采用Grub bootloader。二者的差别见图：</p>

<p><img src="http://pic.yupoo.com/xautjzd/D9TU14LM/medish.jpg" alt="" /></p>

<p>与传统BIOS相比，UEFI BIOS少了BIOS自检功能，这样节省了大量时间，从而加快平台的启动。</p>

<p>安装方法如下：</p>

<pre><code>#pacman -S grub-bios  #install grub bootloader
#grub-install /dev/sda
#grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>

<p>其中grub-install将grub images拷贝到/boot/grub。
grub-mkconfig生成grub的配置，通过-o参数将配置输出到指定的配置文件，默认输出到标准输出。</p>

<h3>13. 卸载分区并重启系统</h3>

<p>卸载分区前先通过<code>#exit</code>退出刚才新安装的系统，然后通过以下方法卸载分区:</p>

<pre><code>#umount /mnt/home
#umount /mnt
</code></pre>

<p>然后通过<code>#reboot</code>重启系统。</p>

<h3>14. 安装图形用户界面</h3>

<p>先确定能否联网：#ping www.google.com,如不能，则查看dhcp服务是否已经开启，可通过<code>dhcpcd interface_name</code>开启。在确保能上网的前提下通过：</p>

<pre><code>#pacman -S gnome xorg
</code></pre>

<p>安装gnome图形用户界面。</p>

<p>经过以上步骤，基本的安装便可完成。我也是安装了好几遍之后才对其安装过程有了大致的了解，写此篇博客的目的主要是为了记录自己的安装过程供今后参考、锻炼自己的写作水平和分享给那些安装ArchLinux过程中碰到问题的朋友参考。</p>

<h3>参考资料</h3>

<ol>
<li><p><a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide">ArchLinux新手指南</a></p></li>
<li><p>Youtube ArchLinux安装视频</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查看网站所用Web服务器类型]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/04/lookup-webserver/"/>
    <updated>2013-09-04T16:43:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/04/lookup-webserver</id>
    <content type="html"><![CDATA[<p>学习Rails的Layout过程中，其中有提到curl，所以便简单的看了下curl的功能。虽说以前学习Shell的过程中也看到过curl,不过没怎么用过，只知道和wget功能类似，只是wget是将请求的web资源下载到本地，而curl则是在shell中显示，至于有什么其他功能也便不清楚。但是今天发现curl其实还可以用来查看website所用的web服务器类型，通过<code>curl -I url-you-want-to-lookup</code>命令查看即可。以下是我查看ruby-china的一个截图：
<img src="http://pic.yupoo.com/xautjzd/D8xXpw6z/medish.jpg" alt="" /></p>

<p>从中可以发现ruby-china采用的是nginx服务器。至于curl其他的功能慢慢再发掘吧。</p>
]]></content>
  </entry>
  
</feed>
