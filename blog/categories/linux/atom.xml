<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | xautjzd]]></title>
  <link href="http://xautjzd.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://xautjzd.github.io/"/>
  <updated>2013-09-13T13:27:48+08:00</updated>
  <id>http://xautjzd.github.io/</id>
  <author>
    <name><![CDATA[xautjzd]]></name>
    <email><![CDATA[xautjzd@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VirtualBox安装ArchLinux系统]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/12/installing-archlinux-in-virtualbox/"/>
    <updated>2013-09-12T22:36:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/12/installing-archlinux-in-virtualbox</id>
    <content type="html"><![CDATA[<p>都说ArchLinux很适合折腾，趁今天有时间，就试着安装了一把，不过看ArchLinux的Beginners&rsquo;s Guide，照着其步骤来，结果还是看的云里雾里，看的人头大。便直接上Youtube上找了一个视频，顿时豁然开朗。安装概览如下：</p>

<h2>ArchLinux Install</h2>

<ol>
<li>分区</li>
<li>格式化分区</li>
<li>挂载分区</li>
<li>更改安装镜像</li>
<li>安装基本系统</li>
<li>生成fstab</li>
<li>Chroot到新系统</li>
<li>配置系统</li>
<li>开启网络服务</li>
<li>创建初始化ramdisk环境</li>
<li>设置root密码</li>
<li>安装配置bootloader</li>
<li>卸载分区并重启系统</li>
<li>安装图形用户界面</li>
</ol>


<p>详细步骤如下：</p>

<h3>1. 分区</h3>

<p>虚拟机挂在iso镜像后，然后启动系统，进入后默认进入root提示符，然后输入：</p>

<pre><code>root#cfdisk
</code></pre>

<p>进行分区，一般分三个即可。最后分区结果如下：</p>

<pre><code>dev/sda1 / 8G
dev/sda2 /swap 1G(在空间最后)
dev/sda3 /home 4G
</code></pre>

<p>每个人的分区情况都可能不同，具体依照自己的分区来决定，以下操作都是根据我的分区来进行。</p>

<!-- more -->


<h3>2. 格式化分区</h3>

<p>执行如下命令格式化分区</p>

<pre><code>#mkfs.ext4 /dev/sda1
#mkfs.ext4 /dev/sda3
#mkswap /dev/sda2
#swapon /dev/sda2  #enable swap partion
</code></pre>

<h3>3. 挂载分区</h3>

<pre><code>#mount /dev/sda1 /mnt #mount root partion
#mkdir /mnt/home
#mount /dev/sda3 /mnt/home  #mount home partion
</code></pre>

<h3>4. 更改安装镜像</h3>

<p>镜像列表优先级从上往下，所以为了软件更新的速度，最好将国内的mirror放到最上面。我添加的源及方法如下：</p>

<pre><code>#vi /etc/pacman.d/mirrorlist

Server = http://mirrors.163.com/archlinux/$repo/os/$arch
Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch
Server = http://mirrors.sohu.com/archlinux/$repo/os/$arch
Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch
Server = http://ftp.tku.edu.tw/Linux/ArchLinux/$repo/os/$arch
...
</code></pre>

<h3>5. 安装基本系统</h3>

<p>通过pacstrap脚本安装基本系统，方法如下：</p>

<pre><code>#pacstrap base base-devel
</code></pre>

<h3>6. 生成fstab</h3>

<p>通过下面的命令来生成fstab：</p>

<pre><code>#genfstab /mnt &gt;&gt; /mnt/etc/fstab
</code></pre>

<h3>7. Chroot到新系统</h3>

<p>通过以下命令chroot到新安装的系统:</p>

<pre><code>#arch-chroot /mnt
</code></pre>

<h3>8. 配置系统</h3>

<p>系统的配置主要有locale和时区的配置。</p>

<ul>
<li>Locale</li>
</ul>


<p>配置方法如下：</p>

<pre><code>#vi /etc/locale.gen
#locale-gen
</code></pre>

<ul>
<li>配置时区</li>
</ul>


<p>系统默认是utc时区，我们需要换到utc+8时区，方法如下：</p>

<pre><code>#ln s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>

<h3>9. 开启网络服务</h3>

<p>先通过ping命令查看网络是否正常，如果不能上网，则需要配置，方法有两种：1.dhcp  2.static ip。我用的是dhcp，所以只需要开启dhcp服务,方法如下：</p>

<pre><code>#dhcpcd interface_name
</code></pre>

<p>其中interface_name可以通过ifconfig或者ip addr查询。默认在虚拟机中便可上网，所以无需配置。但是安装完成重启系统后便不能上网，原因是dhcp服务没启动。(这是我所碰到的情况)</p>

<h3>10. 创建初始化ramdisk环境</h3>

<p>ramdisk是通过软件将一部分内存(RAM)来模拟一个硬盘，提高访问速度。创建ramdisk的方法如下：</p>

<pre><code>    #mkinitcpio -p linux
</code></pre>

<p>通过<code>#vi /etc/mkinitcpio.conf</code>来查看相应的配置信息。</p>

<h3>11. 设置root密码</h3>

<p>设置密码的命令都通用:</p>

<pre><code>#passwd
</code></pre>

<p>然后输入符合要求的密码即可。当然平时操作尽量不要用root,所以为此可以新建一个用户。</p>

<h3>12. 安装配置bootloader</h3>

<p>一般采用比较常见的grub即可。安装方法如下：</p>

<pre><code>#pacman -S grub-bios
#grub-install /deb/sda
#grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>

<h3>13. 卸载分区并重启系统</h3>

<p>卸载分区前先通过<code>#exit</code>退出刚才新安装的系统，然后通过以下方法卸载分区:</p>

<pre><code>#umount /mnt/home
#umount /mnt
</code></pre>

<p>然后通过<code>#reboot</code>重启系统。</p>

<h3>14. 安装图形用户界面</h3>

<p>先确定能否联网：#ping www.google.com,如不能，则查看dhcp服务是否已经开启，可通过<code>dhcpcd interface_name</code>开启。在确保能上网的前提下通过：</p>

<pre><code>#pacman -S gnome xorg
</code></pre>

<p>安装gnome图形用户界面。</p>

<p>经过以上步骤，基本的安装便可完成。我也是安装了好几遍之后才对其安装过程有了大致的了解，写此篇博客的目的主要是为了记录自己的安装过程供今后参考、锻炼自己的写作水平和分享给那些安装ArchLinux过程中碰到问题的朋友参考。</p>

<h3>参考资料</h3>

<ol>
<li><p><a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide">ArchLinux新手指南</a></p></li>
<li><p>Youtube ArchLinux安装视频</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查看网站所用Web服务器类型]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/04/lookup-webserver/"/>
    <updated>2013-09-04T16:43:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/04/lookup-webserver</id>
    <content type="html"><![CDATA[<p>学习Rails的Layout过程中，其中有提到curl，所以便简单的看了下curl的功能。虽说以前学习Shell的过程中也看到过curl,不过没怎么用过，只知道和wget功能类似，只是wget是将请求的web资源下载到本地，而curl则是在shell中显示，至于有什么其他功能也便不清楚。但是今天发现curl其实还可以用来查看website所用的web服务器类型，通过<code>curl -I url-you-want-to-lookup</code>命令查看即可。以下是我查看ruby-china的一个截图：
<img src="http://pic.yupoo.com/xautjzd/D8xXpw6z/medish.jpg" alt="" /></p>

<p>从中可以发现ruby-china采用的是nginx服务器。至于curl其他的功能慢慢再发掘吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash到oh-my-zsh的转变]]></title>
    <link href="http://xautjzd.github.io/blog/2013/08/27/from-bash-to-oh-my-zsh/"/>
    <updated>2013-08-27T18:14:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/08/27/from-bash-to-oh-my-zsh</id>
    <content type="html"><![CDATA[<p>从开始使用到现在一直使用的bash,虽然以前听过ksh,csh,sh等，但都不曾用过，今年开始zsh便不断地出入在眼前，但没真正见人用过，也不知道效果咋样，所以也没做尝试。</p>

<p>另一个原因是各大linux默认都是bash,说明其功能不错，而且也处于懒的原因，就没折腾。但最近在使用tmux的过程中发现bash的提示符只显示<code>-bash4.2$</code>字样，并没有显示成<code>user@hostname directory</code>，在加上西安rubyist的熟人皓哥强烈推荐，这就坚定了我舍弃bash转到zsh的决心，二话不说，立马上GitHub上找到oh-my-zsh。就照着readme开始尝试，结果出现了错误，Google找到答案，是zsh没有安装才导致，所以就<code>yum install zsh</code>安装了zsh,随后在通过</p>

<p><code>curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh</code></p>

<p>安装了oh-my-zsh。不过此时系统默认还是bash,所以还得更改系统默认的shell，方法如下：</p>

<h3>1. 修改/etc/shells文件</h3>

<p>先通过<code>$which zsh</code>查看zsh的位置，我zsh位于/usr/bin/zsh。然后再查看/etc/shells中是否含有zsh:</p>

<p><code>$&lt; /etc/shells grep zsh</code></p>

<p>如果结果中没有/usr/bin/zsh，则需要手动将/usr/bin/zsh添加到/etc/shells文件中。</p>

<h3>2. 更改默认的shell</h3>

<p>通过<code>$chsh -s /usr/bin/zsh</code>更改系统默认shell，退出系统，重新登陆便会发现系统默认的shell已经变为zsh，同时也可以更改zsh默认的主题，在~/.zshrc中更改ZSH_THEME属性即可，其被选的值在<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes">oh-my-zsh theme</a>中任选一个即可。</p>

<p>经过以上两步，oh-my-zsh便安装完成。但是写博客时发现<code>rake new_post["xxx"]</code>时出现<code>zsh: no matches found: new_post</code>错误，Google找到答案，只需改为<code>rake 'new_post["xxx"]'</code>即可，原因是zsh会将一些特殊符号当作查找文件的通配符等，根源解决方法是：取消zsh的通配（Glob），即在~/.zshrc中加入<code>alias rake="noglob rake"</code>。</p>

<p>参考：<a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh官网</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim-airline插件patched font配置成功]]></title>
    <link href="http://xautjzd.github.io/blog/2013/08/26/airline-patched-font-config/"/>
    <updated>2013-08-26T11:30:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/08/26/airline-patched-font-config</id>
    <content type="html"><![CDATA[<p>前段时间装好了airline插件，但是没呈现应有的效果，原因是没有安装字体。根据官网的提示需要安装powerline的字体，我便照着<a href="ttps://powerline.readthedocs.org/en/latest/installation/linux.html#font-installation">powerline官网</a>的配置方法来，但是还是没有成功。其原因是我安装了patched fonts，但是没有将terminal的font设置为patched fonts中的一种，所以statusbar会有乱码。下面对安装patched fonts做一个小结。</p>

<p>安装patched fonts方式请参考:<a href="https://powerline.readthedocs.org/en/latest/installation/linux.html#font-installation">powerline字体配置</a>，尽管文档很详细，但是还是重复一下：</p>

<p>1.Download patched fonts</p>

<p><code>$mkdir ~/.fonts</code>新建一个font文件夹，然后<code>$cd ~/.fonts</code>进入.fonts文件夹。<code>$git clone git@github.com:Lokaltog/powerline-fonts.git</code>将powerline的patched fonts拷贝到~/.fonts目录下，目录结构如下图：</p>

<p><img src="http://pic.yupoo.com/xautjzd/D79oXi6w/medish.jpg" alt="~/.font目录结构" /></p>

<p>2.Install the patched fonts to your System</p>

<p>运行<code>$fc-cache -vf ~/.fonts</code>安装patched fonts到系统中</p>

<p>3.Set Terminal fonts</p>

<p>设置Terminal字体非常重要，我初次配置时，安装patched fonts，但是由于没有set terminal font,所以statusbar显示乱码。设置方法如下：</p>

<p>Edit——Profiles——Default(Edit)——General——Font，选择~/.fonts/powerline下的某一种即可(可选范围一定要在刚才下载的patched fonts中选一种，否则乱码。)，当然也可以采取powerline font installing中的另一种方式，不过我没做尝试，有兴趣的朋友try it。配置截图如下：</p>

<p><img src="http://pic.yupoo.com/xautjzd/D79olvGa/medish.jpg" alt="Font config" /></p>

<p>最后可以在~/.vimrc中更改airline的theme。更改方式如下：</p>

<pre><code>let g:airline_theme="molokai"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim文件的折叠与展开方式]]></title>
    <link href="http://xautjzd.github.io/blog/2013/08/25/vim-folding-and-unfolding/"/>
    <updated>2013-08-25T16:00:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/08/25/vim-folding-and-unfolding</id>
    <content type="html"><![CDATA[<p>最近一直在用Vim学习Ruby,但是一直有个问题困扰：</p>

<p>那就是文件无法折叠，但是我记得以前看过Vim的视频，里面见别人用到了折叠与展开。文件比较小时，此功能便无用，但一旦文件量大时，折叠与展开便显得尤为重要了。</p>

<p>折叠的方式有以下几种：</p>

<ol>
<li>manual</li>
<li>indent</li>
<li>syntax</li>
<li>marker</li>
<li>expr</li>
<li>diff</li>
</ol>


<h3>1. Manual method</h3>

<p>vim默认的折叠方式是此种方式，不需要设置即可。要启用其他方式还得采用<code>:set foldmethod=xxx</code>或者<code>:set fdm=xxx</code>来设置。</p>

<p><strong>使用方法</strong>：</p>

<p><code>v</code>或者<code>V</code>进入visual mode,然后选中要折叠的文字，按<code>zf</code>便可折叠，折叠后按<code>za</code>或者<code>zO</code>便展开。</p>

<p>同时也可以通过<code>zfnj</code>的方式将接下来的n行折叠。类似也有<code>zfnk</code>等;<code>zR</code>则打开所有的折叠。总结下来就是：</p>

<ul>
<li>zf        => create a fold</li>
<li>za        => unfold</li>
<li>zf#j  => fold down # lines</li>
<li>zf#k  => fold up #lines</li>
<li>zR        => unfold all</li>
</ul>


<h3>2. Indent method</h3>

<p>缩进方式主要是根据代码缩进的方式来折叠/展开代码。要使用缩进方式，则需要做配置，<code>:set foldmethod=indent</code>或者在~/.vimrc中配置：<code>set foldmethod=indent</code>。</p>

<p>其快捷键如下：
zM      => fold all
zR      => unfold all
za      => fold/unfold</p>

<h3>3. Syntax method</h3>

<p>采用syntax方式，则只需如下配置即可：</p>

<pre><code>:set fdm=syntax
</code></pre>

<p>按键方式与上述相似</p>

<h3>4. Marker method</h3>

<p> 使用markder方式，则做如下配置：</p>

<pre><code>:set foldmethod=marker
</code></pre>

<p> 或</p>

<pre><code>:set fdm=marker
</code></pre>

<p>默认的marker折叠/展开标记为<code>}</code>.</p>

<p>将要折叠/展开的代码通过<code>}</code>包含起来即可。当然也可以自定义标记。定义方法如下：</p>

<pre><code>:set foldmarker= start,end
eg: set foldmarker= /*,*/

/*
     1. Ruby
     2. Python
     3. C++
     4. PHP
*/
</code></pre>

<p>快捷键如下：</p>

<ul>
<li>za        => fold/unfold</li>
<li>zM        => fold all</li>
<li>zR        => unfold all</li>
</ul>

]]></content>
  </entry>
  
</feed>
