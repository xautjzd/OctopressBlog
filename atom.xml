<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[xautjzd]]></title>
  <link href="http://xautjzd.github.io/atom.xml" rel="self"/>
  <link href="http://xautjzd.github.io/"/>
  <updated>2013-11-27T23:49:31+08:00</updated>
  <id>http://xautjzd.github.io/</id>
  <author>
    <name><![CDATA[xautjzd]]></name>
    <email><![CDATA[xautjzd@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[拆机过程中的一些收获]]></title>
    <link href="http://xautjzd.github.io/blog/2013/11/23/experience-share-about-computer-disassembly/"/>
    <updated>2013-11-23T10:58:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/11/23/experience-share-about-computer-disassembly</id>
    <content type="html"><![CDATA[<hr />

<p>昨天吃完午饭后来到教研室，突然师妹说有个远程(其实只是充分利用教研室的旧机器，在上面发布一些教研室的web项目，还有做为版本控制器的服务器)机器现在不能远程了，尝试关机不得所以强关，然后重启便无法启动，而她的数据在上面。所以我便开始了肢解之路。</p>

<p>由于几乎没有拆台式机的经验，所以拆机过程花费时间比较长，尤其是机箱外盖的拆卸。毕竟是旧机器，没有什么拆机教程可供参考，所以只能摸索着前进了，最后还是使用了点暴力手段才卸下的。拆开后，首先看了下是不是由于接口松动导致无法开机(其实连我自己都不相信是接口松动导致，因为强关不可能导致接口松动吧，可能是为了自我安慰才想到是接口松动的缘故)，查看了一番，便很快排除这个原因。突然想强关的后果很可能就是导致硬盘坏掉，但是起码也应该进入BIOS吧。便猜想是不是电源坏掉导致的原因，老师刚好这时候也出来了，看到我在拆着机，便问我什么情况，我便跟老师一五一十地把情况汇报了一番。然后老师便去隔壁(其实是老师所在部门的办公室)找了一台不能用的机器，我拿过来之后卸下电源重新换上去，当然其中还有不少接线的问题还摸索了一阵,最后才发现电源存在的作用：</p>

<!-- more -->


<ol>
<li>给主板供电。虽然主板肯定要供电，但是所知也仅此而已，具体不知道是如何供电的，直到现在才有所真正明白其过程。</li>
<li>给CPU供电。这个是修理完查资料才发现的。由于CPU嵌在主板上，所以一直以为只要给主板供电便可，详情稍后再介绍。</li>
<li>给硬盘供电。</li>
<li>给光驱供电。</li>
</ol>


<p>换上电源后，尝试开机，发现终于可以进BIOS了，但是系统进不去，心想不是硬盘坏了吧，顿时心凉。索幸我手头有U盘做的Linux启动盘，便换上进入了Linux,最后发现可以识别出硬盘，还能看到硬盘里的资料。这时候便放心了，很可能只是系统坏了(如MBR写入有问题之类),便先把C盘里的重要资料拷贝了一份，然后重新装系统的节奏。拿着同学做的老毛桃进入了WinPE，然后加载XP的iso镜像，准备重装系统，发现WinPE不能加载iso(没用WinPE重装过系统，还真不知道能不能加载iso镜像进行系统重装，待会儿再查吧)。但同学说需要gho镜像才行，便趁他下gho之际，我便继续捣鼓着，换sata线、重新换线上其他接口什么的。然后试着再次启动系统，发现能进入，真的不能不说有点诡异，难道这是上帝在我和开玩笑么?接下来便开始了组装，当然组装之前把里面的灰尘给清除了一番，真一个脏字了得！尘飞扬，手如炭，满地灰。</p>

<p>结束后，便开始了查资料之路。因为在拆机过程中发现有不少接口都不认识，而且有些接口也没有接线，即使接线了，也有一些不知道作用。而我又喜欢刨根问底。首先查了下电源的作用，它主要是给硬盘、主板、CPU和光驱供电。</p>

<p>其中，针对IDE接口的硬盘和SATA接口的硬盘其供电的接口也有所不同。以上所说的IDE和SATA是指数据传输的接口。现在硬盘数据传输接口有IDE、SCCI、SATA、MSATA和PCI—E等。IDE口的硬盘现在市面上已经看不到了，以前的机器一般采用IDE，后来慢慢已经转向SATA,当然SATA有SATA1、SATA2和SATA3，外观没区别，只是传输速率有所不同，SATA1理论传输速率为1.5Gbit/s,而SATA2为3Gbit/s，SATA3则为6Gbit/s。SCSI网上资料显示用于工作站、服务器可能比较多点，当然估计也只是针对以前来说的，现在估计也被淘汰了。现在市面上主流还是SATA，而MSATA则主要用于超级本，毕竟超级本外观所限，再用2.5英寸的就不太合适了。PCI-E则是和显卡一样的接口的固态硬盘，至于它而SATA接口的对比没查资料，也不甚清楚。光驱接口也硬盘一致，感觉有点像孪生兄弟一样，同穿一条裤子。所以有些好事者便拆下光驱，再扩一个硬盘，将系统安装再SSD上，开机速度立马有质的提升。</p>

<p>而给主板充电的接口则主要是24pin的接口，通常为白色，兼容以前的20pin。其实多出的4pin主要是给PCI-E(现在有少数SSD也是采用此接口)显卡供电，如果显卡功耗不大，20pin也是没问题的。</p>

<p>CPU供电接口则有8pin和4pin,以前的可能采用4pin，而今可能都换成8pin了。</p>

<p>内存条接口是比较好识别的，主要有DDR2和DDR3,目前DDR3正在逐渐替代DDR2的主流地位。最好区别它们便是查看它们的防呆口。</p>

<p>最后，说下散热的机制吧。以前的散热一般都是通过金属支架和风扇来进行的。看过比较古董的机器内部构造的人可能都会发现里面有一个大金属疙瘩，而且还有很多槽，这便是金属支架了。金属支架有一面和CPU紧贴，并且表面涂有硅脂，硅质的主要作用是导热，而不是起散热功能，这点可能大家有误解(也许是我想多了，我以前听别人说硅脂是散热的，从此头脑中便将二者等价，真不知到底是受了谁的误导，坑了我好几年啊)。硅脂导热性比较好，将CPU表面产生的高温迅速传给金属支架，然后经由支架将热量散走，金属支架对应的风扇也是为了更快更好的散热而设计的。而现在的笔记本散热一般是通过散热管+风扇将热量排走。拆过笔记本的、看过别人拆笔记本的或是见过笔记本内部构造图的都会发现里面有个铜管，而且还比较长，那个就是散热管，里面是真空，存放有水。要知道，真空状态下水的沸点是比较低的(学过物理的应该都知道吧),所以贴近cpu的一端水很快变成水蒸汽，同时将热量带到另一端再冷却成水，再流回去，还有一个辅助铜管散热的风扇，将铜管的热量散发到空气中。</p>

<p>至于其他的一些接口，也就没必要介绍了，因为要么不常用，要么司空见惯。有兴趣，可以自行查资料。勿听一家之言，否则难免会被误导。</p>

<h2>参考资料</h2>

<p><a href="http://sbgl.jdzj.com/tech/201104/20110425123142_71032.html">http://sbgl.jdzj.com/tech/201104/20110425123142_71032.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[放慢脚步回首过去一个月]]></title>
    <link href="http://xautjzd.github.io/blog/2013/11/21/some-ideas/"/>
    <updated>2013-11-21T20:31:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/11/21/some-ideas</id>
    <content type="html"><![CDATA[<hr />

<p>自上篇文章到现在差不多快一个月了，也因各种琐碎的事情没有闲下来构思一篇博文，顿时有一丝的罪恶感。吃完晚饭洗完澡坐在电脑前突然有种茫然的感觉，上了会儿高端大气的知乎浏览了几个帖子，本想着改下代码，结果发现也打不起精神，便趁此机会来码字来寻求心灵片刻的安宁吧。</p>

<p>首先，说说最近的劳动吧，虽然没啥成果。最近教研室事不多，刚好师姐有个同学需要找人帮忙改个项目，便答应帮忙(当然是有酬劳的，不然也不会闲到改.net的代码，虽然目前还没有谈具体的数字)。其实也不在乎都多少，答应干此活也只是为了积累经验而已，方便日后找工作，同时也算是练手。拿到代码后，我顿时有种欲哭无泪的感觉，代码逻辑及结构之混乱超乎我想象，可以总结为以下几点：</p>

<!-- more -->


<ul>
<li><p>结构混乱，虽然有分层，从下到上大致有DAL、BLL、WebService和Web这几层，然后还有一个Common，里面大致是定义一些通用的操作供DAL调用。但是后来发现代码的逻辑几乎都是在Web层直接进行的，询问得知此系统是在它们以前的OA系统基础上改的，所以保留着以前OA的那种分层结构，只是新开发时没有按照以前的那种分层走。</p></li>
<li><p>命名<strong>极其</strong>糟糕。之所以突出<em>极其</em>二字，是因为它的命名真的已经到了惨不忍睹的地步，有种想撞墙的感觉。我真的怀疑写代码的人知道常见的几种命名法则不，如驼峰命名法、下划线命名法、Pascal命名法和匈牙利命名法(在此提匈牙利命名法，不知道会不会遭人鄙视，之前看到网上已经有太多的人吐槽，连Linus大神也吐槽过)。我个人还是比较青睐于驼峰命名法和下划线命名法，看着很优雅。接着不得不吐槽变量的命名了，一会儿用英文命名，一会儿用对应的拼音，混在一起感觉有点奇葩感。我个人是不太喜欢用拼音，即使不了解，也会用工具将中文翻译成对应的英文再做命名，不知道这算不算强迫症。</p></li>
<li><p>代码逻辑凌乱。逻辑与逻辑间缺少空行分隔，所以有种目不忍视的感觉。还有比较重要的一点是代码重复性太高。比如说省市县三级下拉菜单，很多页面都会用到，但是每个页面都会重复性地写这些代码。如果有机会，我真的会问写此代码的人懂不懂什么叫DRY(Don&rsquo;t Repeat Yourself)，虽然此思想是学习Ruby过程种了解到的，但我觉得可以用于任何语言，放置四海而皆准。毕竟重复性的工作会导致代码的耦合性高，如果今后需要变动，那么每个引用此代码的地方都得做相应修改。</p></li>
<li><p>注释过少。尤其是功能性的注释太少，虽然通过阅读代码最终也能了解，但能不看内部实现便不看，毕竟看代码还是需要花费一定时间的，而且理解可能还会有偏差，所以还是很有必要对代码做相应的功能性注释，不仅方便他人，也方便自己。所以要了解一个人的编码水平，通过观其代码便能略之一二。</p></li>
<li><p>没有使用ORM。我个人也感觉这算是一个弊端，毕竟对于应用开发者来说，效率至上(指开发效率)。虽然直接写Sql语句可能效率更高，但是为此付出的开发时间成本则是不扉，在对性能要求不是很极端的情况下也就显得有些得不偿失。ORM(Object Relationship Mapping)不仅使开发更高效，而且代码也更易阅读，更易维护。反正我了解的应用开发一般都会用到ORM,如.net的EF(Entity Framework),Java的Hibernate、Mybatis等，Ruby的ActiveRecord等。其他语言也应该有相应的ORM,不过不了解，我了解的就是这三门语言，所以也便能说出一二。</p></li>
</ul>


<p>说了这么多弊端，不知道是不是由于我平时的开发一般都是MVC模式，所以对其他的开发模式看不习惯所致。不管怎样，还是得硬着头皮改完吧，既然承诺于人，便得有始有终，这也算是我一贯的办事风格吧。</p>

<p>其次，由于老师让看Hadoop,所以便时不时的看看云计算和Hadoop这块，算法还真不是我的强项，看到朴素贝叶斯和KNN算法，真的是看不下去，尤其用MapReduce实现。MapReduce程序真的是和一般的代码差别有点大，把握不住运行的脉络，一旦看不清脉络，便有种管中窥豹的感觉。身边也没有搞Hadoop的人，想找个人聊聊都困难。网上吧，提的问题太过白痴，也往往遭人鄙夷，从此便被无视。这算是如今最头疼的事了。</p>

<p>最后，说说加入Rubyists的情况吧。2012年，Oschina在西安举办OSC，作为开源的爱好者与拥护者便跑去参加了。正是这次机缘巧合接触了Ruby，接着便花了一些时间去了解Ruby和Rails。在RubyChina社区上又无意看到了一个关于西安Rubyists线下活动的召集贴，便报名参加了，从2013.7第一次参加到现在也差不多5个月了，也就是5次活动(每月一次),要说最大的收获应该就是眼界的拓宽，对IT行业有了一个更深的认识，对新技术也有了一点了解，如angularjs,远程工作的一些工具，同时也更加坚定了自己对Git/GitHub(以前一直都是一个人在使用，身边的同学还没发现使用Git，用了svn都算不错了)及Vim的使用。Vim以前也只是会一些基本操作，配置都是拷贝网上现成的，到现在的熟练运用，可以说也算是有质的飞跃了。虽然目前一直在Rubyists中一直处于索取的状态，不过相信迟早也会奉献的，可以讲讲Vim的操作、配置及常用插件等。</p>

<p>PS:刚在知乎上看到某人专栏上的一篇文章，觉得有部分写的不错，便搬过来吧，当然不是完全照搬，我会结合我自己切身的经历用自己的语言描述出来。大致如下：</p>

<p>由于我所学的专业为计算机，所以我对这一领域有找寻答案的能力，因此在碰到问题时能很快的定位答案，予以解决，真的可谓时见招拆招。如果换作非计算机专业的人来说，可能显得稍微吃力。当一个人想知道[门]背后有什么的时候，他需要的只是开启门的钥匙，而这个钥匙刚好在我手里，因为即使我也不知道门背后有什么，但我却能够将门打开，让大家看到这门背后到底是什么。而帮人解决问题的过程则让我了解门背后的东西，还收获了开启各种门的方法。</p>

<p>我以前老喜欢上网浏览信息，比如说CSDN、新浪微博、RubyChina等，但慢慢这种趋势有所下降。因为我感觉看的东西再多，慢慢也便淡忘，从上面所了解的知识再丰富、再专业，也不过是碎片化的，不会提供一个系统的知识，所以也便不可能形成完整的知识结构。没有一个完整的知识结构，知识储备便很难有质的突破。所以我也慢慢更多地转向了书本的学习，毕竟从书本上看的东西还是比较系统化。</p>

<p>最近在阅读的一本书是《高效程序员的45个习惯》，真心值得一读。身处碎片化的时代，能够静下心来读一本书真的很不容易。希望接下来的日子里能将看微博、豆瓣等时间更多的分给读书。不知不觉已经10点多了，就这样断断续续的竟写了三个小时，到此结束吧，也算是最自己近一个月来的总结。不认识过去，便看不清未来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim寄存器]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/27/vim-registers/"/>
    <updated>2013-10-27T16:37:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/27/vim-registers</id>
    <content type="html"><![CDATA[<hr />

<p>谈Vim寄存器前先对昨天做个总结吧。Rails Girls昨天在西安的ThoughtWorks成功举办，目的是帮女性程序员了解Ruby &amp; Rails，报名参加的学员大概有30多人，教练大致有10来个，由于活动是ThoughtWorks和西安的Rubyists一起合作举办，所以我作为西安Rubyists的一员报名当了教练(由于教练奇缺，而我们Rubyist成员大多都去北京参加RubyConf了，所以我作为Rubyists里面的菜鸟报名当教练了，去了发现除我外，其他教练都是TW员工,顿时汗颜)。</p>

<!-- more -->


<p>每个教练指导2-3个学员，人员的分配通过软件随机组合，没想到竟然给我分了3个！不过幸好有指导教程，指导起来便没有无从下手的感觉，由于报名的学员几乎都没接触过Rails,所以指导难度不是很大，大概从环境的配置到一个简单的web应用生成方面进行了指导，然后加上TW准备的几个Session演讲，一天也就过去了，临近结束，没想到竟然碰到同一个县城的老乡，真的太意外了。临走前还一起吃了个饭，聊了估计有差不多一个小时，然后匆忙的坐车回学校了，到学校门口天早已漆黑一片，感觉特别累，到教研室待到差不多11：00便回宿舍睡觉了。有时候真的在想，要是上班了那不得累趴下！这还什么事都没干就这么累。</p>

<p>不知不觉码字码了这么多，但感觉毫无重点，还是进入正题吧，不然就感觉文不对题了。</p>

<p>Vim的寄存器类型请通过<code>:help registers</code>查看，下面只介绍两种：</p>

<ol>
<li>数字寄存器</li>
<li>字母寄存器</li>
</ol>


<h2>1. 数字寄存器</h2>

<p>数字寄存器大致有10种，编号从0-9，并且都以<code>"</code>开头，通过<code>:reg</code>便可查看。其中<code>"0</code>保存上次<strong>复制(y)</strong>操作的文本，而<code>"1——"9</code>寄存器则保存最近9次<strong>删除</strong>的文本<strong>行</strong>,<code>"1</code>保存的是最近一次删除的内容，如果又有新的操作，则将1保存到2中，然后1保存最新内容。</p>

<h2>2. 字母寄存器</h2>

<p>字母寄存器从a-z或者A-Z,其中指定a-z会替换掉他们先前存储的内容，而A-Z则会在它们先前保存的内容中追加新内容。</p>

<p>一般paste可能都通过来操作，这仅粘贴0或1寄存器中的内容,要想粘贴内容其他寄存器的内容，则需通过<code>寄存器的名称+p</code>来操作。如将内容保存到a寄存器中，则可在normal模式下输入<code>"ayy</code>，将光标当前行内容存储在a寄存器中，粘贴便可通过<code>"ap</code>来操作。</p>

<p>寄存器可能平时用不上，一般在需要录制宏的时候才会用到。想要更深入的了解，还是<code>:help registers</code>看帮助文档吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop集群]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/22/hadoop-cluster-1/"/>
    <updated>2013-10-22T20:51:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/22/hadoop-cluster-1</id>
    <content type="html"><![CDATA[<hr />

<p>最近开始研究起Hadoop,《Hadoop in Action》大概看了3章，然后开始着手搭建环境。</p>

<p>由于设备的受限，让老师给分了两台虚拟机（4G内存，20G硬盘，CentOS6.4），在上面开始搭建Hadoop集群，其中一台作为master,另一台作为slave。环境的搭建大概花了一天多的时间，主要有JDK的配置和SSH的配置，这两项已经是轻车熟路，所以很快便配置好。但是Hadoop才刚接触，所以配置起来速度慢点，没有一个绝对的参考资料，网上资料虽颇丰，但甄别对与错却需要一定时间，并且还要弄懂配置参数的意义。前后大致花了有半天时间。配置好后启动服务时却出错，google搜索了好久，也试过很多方法，但一直没解决。</p>

<!-- more -->


<p>问题主要出现在权限这块，因为采用root启动服务没问题，但是一般用户启动便提示创建<code>/var/logs/user</code>出错，权限不够，而我的logs目录已经在<code>conf/hadoop-env.sh</code>中设置为hadoop解压目录下的logs目录。最后实在没辙，便尝试重新配置。大致步骤也是按前边的进行，但是没想到最后竟然成功，真的太让人意外！通过jps能够看到master的namnode,jobtracker等的进程号，同时也能在slave上看到datanode,tasktracker的进程号。</p>

<p>安装好后，当然得找个实例测试下，hadoop的解压目录下自带有example，其中有个wordcount,便拿来测试了。</p>

<h3>创建本地测试文件</h3>

<pre><code>$mkdir ~/file
$cd ~/file
$echo "Hello World" &gt;&gt; ~/file1.txt
$echo "Hello Hadoop" &gt;&gt; ~/file2.txt
</code></pre>

<h3>在HDFS上创建Input目录</h3>

<pre><code>$hadoop fs -mkdir input
$hadoop fs -ls
</code></pre>

<h3>导入本地测试文件到HDFS中的input目录</h3>

<pre><code>$hadoop fs -put ~/file/file*.txt input
$hadoop fs -ls input
</code></pre>

<h3>运行wordcount程序</h3>

<p>以input为输入目录，output为输出目录</p>

<pre><code>$hadoop jar ~/hadoop-1.2.1/hadoop-examples-1.2.1.jar wordcount input output
</code></pre>

<h3>查看结果</h3>

<p>运行的结果会保存在output下的part-r-00000文件中，查看方法如下：</p>

<pre><code>$hadoop fs -cat output/part-r-00000
</code></pre>

<h3>后话</h3>

<p>近两天在看龙应台女士的《亲爱的安德烈》一书，全书以书信的方式来展开，通过她与儿子安德烈的对话，了解了香港、台湾及德国的一种生活方式，尤其是香港人民2005年的游行，不禁让我想到了中国的现状，顿时有种压抑的感觉，感觉中国人民一直在努力的奋斗，无非就是为了一份安宁的生活。但感觉就是这么一份安宁，却让太多的人为之奋斗一生而不得或千辛万苦才得，突然觉得这样的人生还有意义么？我目前期望的仅是今后能生活在技术圈中，而且不用再被生活所奴役，不愿再面对一群不懂技术而趾高气扬的人，已经听到身边不少人羡慕国企、银行、研究所等铁饭碗的单位，但我却丝毫没有兴趣，因为在我印象中，那些单位大多给人一种散漫感，其中充满了太多的勾心斗角，尔虞我诈，而我本身却非常厌恶这些，真的可以说让人作呕。呆在这样的环境工作一生，想想都觉得枯燥无味。希望明年能找到一份理想的工作，干自己喜欢的技术。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Putty SSH中文乱码]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/18/ssh-messy-code/"/>
    <updated>2013-10-18T10:59:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/18/ssh-messy-code</id>
    <content type="html"><![CDATA[<hr />

<p>由于Fedora安装在教研室的台式机上，小组的活动在科协，每次去又免不了使用Linux环境，所以<strong>Putty</strong>便派上用场了。Putty作为Windows下的SSH工具，确实很方便，解决了很多不必要的麻烦，但是发现在使用的时候，中文显示乱码。求救Google的时候到了，网上一搜，真的是一大堆，随便查看了一篇博客，照着试了一下便解决。方法如下：</p>

<blockquote><p>windows->Appearance->Translation,在其中将字体改为UTF-8便没问题。</p></blockquote>

<p>问题确实能解决，但是发现不能保存设置，每次打开Putty时都需要重新设置，这点有待改进,不知道是我安装的putty版本过低还是其他的缘故。在分享中成长，在成长中分享，大胆的分享吧，Don&rsquo;t be shy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些感想]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/15/some-feelings/"/>
    <updated>2013-10-15T19:55:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/15/some-feelings</id>
    <content type="html"><![CDATA[<hr />

<p>如果要评价自己的话，那么我会将自己归为乐于分享的一类，不管是技术还是工具，亦或代码。平时也都关注一些科技新闻和博客，每当发现不错的信息时，都会想着第一时间将其分享给身边的朋友。</p>

<p>分享过的工具中记忆比较深的当属Git，GitHub，Evernote和Vim了，系统方面则有Linux，编程方面则有Ruby。虽然可能最终用的人不是很多，但起码他们脑海中已经有了这个词，我觉得这也就够了，毕竟大部分人还是守旧派，不愿接触新鲜事物。但自己这颗乐于分享的心却从未动摇过，只要有好东西，绝对第一时间分享。但总会有那么一些人会对我的举措有误解，认为我是一个喜欢炫耀的人，推荐给大家一些他们闻所未闻的新鲜事物是为了证明我的牛，我只能一笑置之，也不想多做辩解。因为解释过多，可能又会有人说“解释是为了更好的掩饰”，所以沉默是最好的回应。</p>

<!-- more -->


<p>我只想在自己技术和知识面的提升时，同时也能够帮助身边的人有所进步。只想带给大家正能量，因为我一直觉得一个人不管多有才，如果不能影响身边的人，那么他的存在价值便为0，一个人于他人无益，便只能说他白活了。最后只想说一句：</p>

<blockquote><p>走自己的路，让他人去说吧！</p></blockquote>

<p>如果你是一个喜欢码字的人，并且觉得jekyll或者Octopress难以配置的话，那么Ghost也许是不错的选择，并且支持Markdown的格式。具体介绍，请参考<a href="http://ghost.org/">Ghost官网</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux硬链接与软链接]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/10/linux-hard-link-vs-soft-link/"/>
    <updated>2013-10-10T09:42:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/10/linux-hard-link-vs-soft-link</id>
    <content type="html"><![CDATA[<hr />

<p>链接的概念其实不仅限在Linux中，在类Unix和Windows中也存在，只是网上资料大多都讨论的是类Unix的链接。下面主要对所了解的类Unix下的链接谈谈自己的认识。</p>

<h3>链接存在的目的</h3>

<p>链接的出现主要是为了解决系统中文件的共享，同时有其他附加的好处：隐藏真实文件路径、增加权限安全及节省存储。简单的举例说明：</p>

<p>Linux中有7种run level(0-6),其中0代表关机，1代表单用户模式(用于系统维护，禁止远程登陆),2代表多用户状态(不支持NFS)，3代表完全的多用户模式，4系统保留(未使用),5代表X11模式(GUI模式)，6则代表重启。</p>

<p>这7种模式分别对应/etc/rc.d/rcN.d目录(N指0-6之间的数字)，存储的是每种启动模式下要启动的程序，但实际的程序其实存储在/etc/rc.d/init.d目录中，/etc/rc.d/rcN.d中都是链接而已，链接到/etc/rc.d/init.d目录中对应的程序(这样做的目的是为了管理上的方便，试想一下，如果有多个runlevel包含同一个程序，需要对这个程序的启动脚本进行修改时，只需更改/etc/rc.d/init.d中的实际文件，而不需要改动/etc/rc.d/rcN.d)。</p>

<h3>链接的分类</h3>

<p>链接分为两种：硬链接(hard link)与阮链接(soft link)。谈链接就不得不谈inode，所以先简单地介绍下inode。</p>

<!-- more -->


<p><strong>inode</strong></p>

<p>类unix中，文件被分为两部分：用户数据(user data)和元数据(metadata)。用户数据，即文件数据块(data block),数据块是记录文件真实内容的地方，而元数据则是记录文件的附加属性，如文件大小、创建时间、所有者等信息。而inode则负责存储这些元数据，inode确切的说是一个数据结构，包含了文件的所有信息(文件名除外)。inode包含的详细信息为：</p>

<ul>
<li>Inode number</li>
<li>Access Control List(ACL)</li>
<li>Extended attribute</li>
<li>Direct/indirect disk blocks</li>
<li>Number of blocks</li>
<li>File access, change and modification time</li>
<li>File deletion time</li>
<li>File generation number</li>
<li>File size</li>
<li>File type</li>
<li>Group</li>
<li>Number of links</li>
<li>Owner</li>
<li>Permissions</li>
<li>Status flags</li>
</ul>


<p>通过<code>ls -i</code>或者<code>stat filename</code>可查询文件对应的inode信息</p>

<p>文件新建时，内核会分配一个inode,每个文件的inode号唯一，可以简单地将其理解成指针，指向对应文件的具体的存储位置。访问文件时，inode会被复制到内存，然后根据inode将对应的文件复制到内存。</p>

<p><strong>硬链接</strong></p>

<p><img src="http://pic.yupoo.com/xautjzd/DdZo1Za8/medish.jpg" alt="" /></p>

<p>如图，硬链接其实就是在现有文件上添加了一个别名，他们有共同的inode,但硬链接有以下不足：</p>

<ol>
<li>不能跨文件系统(inode号仅在同一文件系统下唯一，当挂载多个文件系统后，便可能会出现inode号重复的现象，所以不能跨文件系统)</li>
<li>只能针对文件创建硬链接，不能对目录创建</li>
</ol>


<p>每个inode都有一个链接计数器,默认文件的inode计数器值为1,每当创建一个硬链接，计数器值便加1，而删除文件时，其实是计数器值减1，只有当计数器为0时，文件才从物理磁盘上删除。</p>

<p>下面看一个实例：</p>

<pre><code>265092 -rw-rw-r--   2 fedora fedora         0 Oct 10 14:16 test
265092 -rw-rw-r--   2 fedora fedora         0 Oct 10 14:16 testdl
265164 lrwxrwxrwx   1 fedora fedora         4 Oct 10 14:18 testsl -&gt; test
</code></pre>

<p>其中test为新建的测试文件，testdl是在test上建立的硬链接，testsl是在test之上的软链接。可以发现test与testdl的inode号相同，而test与testsl的inode号则不同，在创建了硬链接之后，test与testdl的计数器变成2了。</p>

<p><strong>软链接</strong></p>

<p>软链接(也称符号链接 symbol link)刚好弥补了硬链接的不足，不存在文件系统的限制，同时也可以创建指向目录的符号链接。所以现在广泛使用的一般是软链接，它具有更强的灵活性。但它同时也具有硬链接没有的缺点，那就是：</p>

<ol>
<li>软链接包含原有文件的路径信息，一旦原文件移到其他路径下，再访问软链接，便找不到了，硬链接则无影响。</li>
<li>系统会为软链接分配额外的空间用于建立新的inode并保存原文件的路径</li>
</ol>


<h3>软链接与硬链接的区别</h3>

<ol>
<li>硬链接与原文件inode号相同，表明他们是同一个文件；而软链接与原文件inode号不同，说明他们是两个不同的文件。(上图便可看出)</li>
<li>文件属性上软链接明确标明了是链接文件，而硬链接则没有，因为在本质上硬链接与原文件是完全平等的关系。</li>
<li>链接计数器不同，软链接的计数器不会增加。</li>
<li>文件大小不同，硬链接文件显示的大小与原文件相同，而软链接则显示的大小与原文件不同。</li>
</ol>


<h3>参考文档</h3>

<ol>
<li><a href="http://www.cnblogs.com/ovliverlin/archive/2008/10/28/1321521.html">http://www.cnblogs.com/ovliverlin/archive/2008/10/28/1321521.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下锐捷客户端上网]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/09/surf-internet-under-linux-about-ruijie/"/>
    <updated>2013-10-09T17:17:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/09/surf-internet-under-linux-about-ruijie</id>
    <content type="html"><![CDATA[<hr />

<p>自己虽然一直用的校园网，但是由于教研室这块位置比较特殊，不需要使用锐捷客户端认证，但其他地方一般都需要。所以今早有个朋友在笔记本上安装了Ubuntu，但是无法通过锐捷web方式认证，下载的锐捷Linux版客户端安装后也无法上网，所以这方面我也不熟悉，只能求助Google了。由于众多高校的网络都是使用锐捷的这一套，所以大同小异，这方面的资料也不少，Google搜索很快便找到了解决方法，用华科的一个客户端即可，下载地址：<a href="http://code.google.com/p/mentohust/">http://code.google.com/p/mentohust/</a></p>

<p>下载后，切换到下载的目录，然后运行<code>sudo dpkg -i 'your deb packagename'</code>即可，安装过程中，一步一步按照其步骤输入相应信息即可。安装完成后，会将配置的信息存储在<code>/etc/mentohust.conf</code>文件中，也可进行修改。在安装的过程中，如果采用DHCP方式，在选择时应该注意，选择1或者2，千万别选择3，否则上不了网。各选项的含义是：</p>

<p>-d DHCP方式：0（不使用） 1（二次认证）2（认证后）3（认证前）</p>

<p>关于mentohust的详细参数解释，请参考<a href="http://code.google.com/p/mentohust/wiki/Parameter">官网wiki</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fedora下使用sudo]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/08/use-sudo-in-fedora/"/>
    <updated>2013-10-08T15:11:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/08/use-sudo-in-fedora</id>
    <content type="html"><![CDATA[<hr />

<p>Linux下日常操作使用一般用户权限即可，但是往往有一些操作需要用到root权限，如服务的启动、软件的安装等，直接转到root下进行操作可不是一个好习惯，比较稳妥的方式就是使用sudo进行操作。首先检查系统是否已经安装<code>sudo</code>,接下来需要在<code>/etc/sudoers</code>文件下进行配置相应的权限。</p>

<p>在<code>root    ALL=(ALL)   ALL</code>这行下面添加<code>username ALL=(ALL) NOPASSWD:ALL</code>即可。其中<code>username</code>为要使用sudo的用户，并且每次使用sudo时不需要输入root密码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[梦想]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/01/whats-my-dream/"/>
    <updated>2013-10-01T22:48:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/01/whats-my-dream</id>
    <content type="html"><![CDATA[<hr />

<p>你要搞清楚自己人生的剧本——不是你父母的续集，不是你子女的前传，更不是你朋友的外篇，对待生命你不妨大胆冒险一点，因为好歹你要失去它。如果这世界上真有奇迹，那只是努力的另一个名字，生命中最难的阶段不是没有人懂你，而是你不懂你自己。——尼采</p>

<p>当读到这段话时，我陷入了沉思，不禁想：人生短短几十年，生命的1/3差不多已悄然而逝，在这1/3的年华中自己收获了什么，失去了什么。我想得到的可能就是人们眼中所谓的专业知识，比一般人士更了解计算机而已，同时可能收获的是思考问题和解决问题的能力。而失去的确是童年该有的肆无忌惮的玩耍，天马行空的想法，取而代之的是那铜墙铁壁似的教室的囚禁，被教导做个父母、老师眼中的乖孩子，死记硬背那些该死的口诀表和公式。</p>

<!-- more -->


<p>熟不知imagination is more important than knowledge。如今的我们早已丧失了孩童时代的那种超凡想象力，它们早已被所学的知识所囚禁，想要挣脱却不得。同时我们变得没有梦想，确切的说是终极梦想。仅有的只是阶段性梦想，小学开始便想着如何努力学习上重点初中，中学三年该如何发奋上个理想的高中，高中三年挥洒着汗与泪争取上个令人满意的大学，上了大学便开始思索如何学习才能毕业后找个好工作。找着工作后可能便又想着买房结婚的事了。</p>

<p>我们有自己的终极梦想么？我们是否一直为之做不懈的努力呢？我扪心自问，我没有一个从小到现在一直在坚持的梦，唯一有的只是阶段性的，每当完成时，不禁窃喜。不过随着时间的流逝，这种成就感也便逐渐消散，直至不复存在。所以难免会有迷茫，有时会突然觉得空虚，便开始质疑生活的真谛、存在的意义。心若空了，便干什么都会觉得没劲，不过这种日子往往是短暂的。因为一直都在忙碌，忙着学习专业知识，以求跟上时代的步伐，跟上大流，毕竟计算机更新换代太快，要学的实在太多。正是忙着学习，可能忘了反思，忘了生活的意义，这种学习与生活混为一体的日子真是我想要的么？我想我无法回答。</p>

<p>以前没有梦想，是因为接触的事物当中没有一件是我心动的，都不足以支撑我为之拼搏。现在我想我找到了，那就是成为一名Geek,虽然还非常遥远，但是我却能始终朝着那一方向努力。每次看《Unix网络编程》和《Unix环境高级编程》时，总会为那些非凡的设计所折服;学习Ruby时，会被其亲切自然的语法所吸引;使用Linux和Vim时，总能感觉到其魅力;当了解了某一原理时，便不胜欣喜。I love it.</p>

<p>以前之所以没有一个为之努力奋斗的梦想，我想是因为接触的不够多的缘故吧。所以小孩子应该重点拓宽他们的知识面，让他们找准自己的兴趣所在，而不是一味求深，还给他们一片自由的空间吧！中国的教育何时能有质的提升？希望在有生之年能够看到。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dead Code]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/29/dead-code/"/>
    <updated>2013-09-29T10:09:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/29/dead-code</id>
    <content type="html"><![CDATA[<hr />

<p>今天在网上看到腾讯的一个实习生招聘题，里面提到了dead code，便上wikipedia查了下，解释如下：</p>

<p>在计算机编程中，dead code是指那些被执行但执行结果在其他地方没有用到的代码。dead code的执行耗费cpu时间但是结果无用。</p>

<p>dead code的执行结果没用也就罢了，但它还可能同时导致异常或影响某些全局状态，所以移除这些dead code可能会改变程序的输出，并且排除那些意想不到的bugs。</p>

<p>参考文档：</p>

<p><a href="http://en.wikipedia.org/wiki/Dead_code">http://en.wikipedia.org/wiki/Dead_code</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机启动过程]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/26/boot-process/"/>
    <updated>2013-09-26T18:48:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/26/boot-process</id>
    <content type="html"><![CDATA[<hr />

<p>计算机启动过程的详细介绍请参考阮一峰老师的两篇博文：</p>

<ol>
<li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">http://www.ruanyifeng.com/blog/2013/02/booting.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html</a></li>
</ol>


<p>写的非常通俗易懂，真的很佩服阮老师的文笔，有时候自己写的博客自己都有点目不忍视，更何况别人呢。要达到这样的水平真的还有好长的路要走。加油吧</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASP.NET MVC Json()处理大数据异常解决方法]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/26/json-serializer-maxjsonlength-exception/"/>
    <updated>2013-09-26T15:15:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/26/json-serializer-maxjsonlength-exception</id>
    <content type="html"><![CDATA[<hr />

<p>近几天一直忙于windows下的项目，rails的学习暂时搁置了，所以也有好几天没有用fedora了，博客大致也有一周没有更新。此博客本想只记录一些Linux平台下的相关操作，但这两天碰到的问题很棘手，虽最终得以解决，但不忍就此翻篇，想将解决之法记录下来，以避免今后再次碰到此类问题又得重头再寻求解决方案，同时也分享出来，避免其他人碰到此问题时多走弯路。所以便予以记录。下面切入正题：</p>

<p>先对项目做个简单介绍：</p>

<!-- more -->


<p>整个项目采用微软的ASP.NET MVC3进行开发，前端显示采用EasyUI框架，图表的显示用的是Highcharts，主要进行曲线图的绘制，这样比较形象地描绘出变化的趋势。由于数据量比较大(大于1000，000条记录)，而highcharts接受的数据类型为json格式，所以controller从数据库中取出的数据需要先格式化成json,然后再传到前端。平时一直采用MVC的Json()将数据序列化成json格式，但是由于此次数据量较大，所以曲线不显示，所以一直以为是由于数据量较大，highcharts插件不支持100w级数据，后来听人说highcharts本身是支持100w级数据的。最后采用firebug调试才发现出现了错误：“使用JSON JavaScriptSerializer进行序列化或反序列化时出错。字符串的长度超过了为maxJsonLength属性设置的值”,网上也找了不少解决方案，几乎无一例外说的是在web.config的<configuration>节点下添加：</p>

<pre><code>&lt;system.web.extensions&gt;
    &lt;scripting&gt;
        &lt;webServices&gt;
            &lt;jsonSerialization maxJsonLength="1024000000" /&gt;
        &lt;/webServices&gt;
    &lt;/scripting&gt;
&lt;/system.web.extensions&gt;
</code></pre>

<p>试过后发现曲线还是没出来，最后拿出杀手锏：谷歌翻译成英文，再次搜索，最后终于在stackoverflow上找到解决之法：</p>

<pre><code>public ActionResult GetLargeJsonResult()
{
  return new ContentResult
    {
        Content = new JavaScriptSerializer { MaxJsonLength = Int32.MaxValue }.Serialize(myBigdata),
        ContentType = "application/json"
    };
}
</code></pre>

<p>具体网址：<a href="http://stackoverflow.com/questions/4155014/json-asp-net-mvc-maxjsonlength-exception">http://stackoverflow.com/questions/4155014/json-asp-net-mvc-maxjsonlength-exception</a></p>

<p>这里不得不大赞StackOverflow,好多问题都是在上面找到solution,而且上面还有非常多的好心人士热心细致的回答问题，我提了好几个问题都最终得到所谓Geek的帮助并得以解决。这里，我只想说声：谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby语言独特点]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/19/ruby-syntax-special-point/"/>
    <updated>2013-09-19T09:05:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/19/ruby-syntax-special-point</id>
    <content type="html"><![CDATA[<hr />

<p>有时候真佩服别人的博文可以写的那么长，而且很有料，读起来也非常顺畅，而自己每次却不太善于总结，可能是平时积累的片段还不够，不足以总结，亦或是自己缺少这么一个总结性的思维，导致如今为止也没有产出一篇广为阅读的文章。不过即使如此，也没有打消我持续写博客的念头，不管好坏，不管是否有读者，我将会一如既往的写下去。正如哥哥的《我》:我就是我，是颜色不一样的烟火。每个人都有他存在的价值，无论高低贵贱，无论贫穷富贵，都有其独一无二不可替代的特性。所以无论自己的博文是否能带给大家一丝感触、一点帮助，我都会坚持，因为这也是对我自己学习的一个总结，同时也想尽力贡献一份自己的力量来帮助他人，但我想更多的还是能帮助自己，以便为未来某一天突然需要回味从前的知识提供便捷。我想这便是写博客的初衷。下面进入正题吧：</p>

<!-- more -->


<h2>无须声明变量</h2>

<p>Ruby第一个独特之处我想应该是定义变量时无须指定变量类型吧。eg:</p>

<pre><code>time = Time.now
i = 1
text = "hello,world"
</code></pre>

<p>虽说变量定义时无类型，但是当为其赋值后类型便确定了。</p>

<h2>一切皆对象</h2>

<p>另一个特点应该非<code>一切皆对象</code>莫属了，即使是简单的变量也是一个对象，可通过class方法查看其类型：</p>

<pre><code>1.class           #=&gt;Fixnum
1.1.class         #=&gt;Float
"test".class      #=&gt;String
[].class          #=&gt;Array
{}.class          #=&gt;Hash
</code></pre>

<h2>Mixin</h2>

<p>而Mixin应该算是其第三个独特之处，通过在Class中mixin Module以达到类似c++里面的多重继承吧，虽然ruby中没有多重继承这个概念。eg:</p>

<pre><code>module Hello
    def say_hello
     puts "hello!"
    end
end

class TestClass
    include Hello
end
</code></pre>

<p>这样TestClass即使内容为空，但因为有Hello的mixin，所以也拥有say_hello方法。</p>

<h2>yield</h2>

<p>yield真的是Ruby的一大亮点，也是我所学所了解的语言当中最独特的部分，同时也是我深爱Ruby的原因。yield通俗的讲其实就是一个占位符，提前帮block占好位置。block可以再程序运行的时候动态传给方法。eg:</p>

<pre><code>class Test
    @data = [1, 2, 3, 4]

    def test
        if block_given?
            @data.each { |e| yield(e) }
        else
            puts "please give block"
        end
    end
end

obj = Test.new
obj.test { |x| puts x*x }  #=&gt;1, 4, 9, 16
</code></pre>

<p>定义时可以不指定具体操作，先用yield占位，然后待到具体操作时，将具体处理的block传入方法。</p>

<h2>写在结尾的话</h2>

<p>自己断断续续学习Ruby大致也不到一年时光，所以理解也不是很深入，只将我自己所理解的所看到的所学到的列举出来。其实自己也看过《Meta Programming》，深深为method_missing，eval等所折服，但是还是理解不到家，所以也不敢妄自胡言乱语，以免贻笑大方。深入的东西留待后续的学习吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim常用快捷键总结]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/18/vim-shortcut-maps/"/>
    <updated>2013-09-18T19:55:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/18/vim-shortcut-maps</id>
    <content type="html"><![CDATA[<hr />

<p>Vim的学习之路真的很长，永远有记不完的命令，永远会突然冒出一个新插件。不过我总算从Vim的荆棘中一路走过来了，现在真的是苦尽甘来，时刻体会它带给我的喜悦和惊奇。下面对我所学习所了解到的常用命令做一个基本总结：</p>

<h3>Normal mode:</h3>

<p><code>&gt;&gt;</code> indent current line</p>

<p><code>n&gt;&gt;</code> indent the next n line</p>

<p><code>.</code> repeat last command</p>

<p><code>m,n&gt;&gt;</code> indent from m to n line</p>

<p><code>==</code> autoindent current line</p>

<p><code>n==</code> autoindent the next n line</p>

<p><code>gg=G</code> autoindent the whole file</p>

<!--more-->


<p><code>=i{</code> reindents &lsquo;inner block&rsquo;(inside the braces)</p>

<p><code>=a{</code> reindents &ldquo;around block&rdquo;(including the braces)</p>

<p><code>=2a{</code> reindents 2 blocks(this block and containing block)</p>

<p>instead of &ldquo;{&rdquo;, also can use &ldquo;}&rdquo; or &ldquo;B&rdquo;.<code>=aB</code> equals <code>=a{</code></p>

<p><code>&gt;i{</code> increase indent for inner block</p>

<p><code>&lt;i}</code> decrease indent for inner block</p>

<p><code>&gt;a{</code> increase indent for around block(including the brace)</p>

<p><code>&lt;a}</code> decrease indent for around block</p>

<p>With the cursor on <code>{</code> or <code>}</code></p>

<p><code>=%</code> autoindent the block(including matching brace)</p>

<p><code>&lt;%</code> or <code>&gt;%</code> indents or unindents the block</p>

<h3>Insert mode:</h3>

<p><code>&lt;c+t&gt;</code> indent the current line</p>

<p><code>&lt;c+d&gt;</code> reindent the current line</p>

<h3>Surroud plugin</h3>

<p>以下是一些surround插件的功能：</p>

<pre><code>{
    xxx
    xxx
}
</code></pre>

<p>normal模式下输入：dS{,结果变为:</p>

<pre><code>xxx
xxx

"hello world"
</code></pre>

<p>cS&#8221;&lsquo;之后，结果变为：</p>

<pre><code>'hello world'

&lt;div&gt;hello&lt;/div&gt;
</code></pre>

<p>通过cSt然后输入<code>&lt;p&gt;</code>,结果变为：</p>

<pre><code>&lt;p&gt;hello&lt;/p&gt;
</code></pre>

<p>当然也可以选进入visual模式，然后S&#8221;，便给选中的文本包含&#8221;&ldquo;。</p>

<p>以上命令主要是关于缩进和对齐的一个总结，关于surround插件做的总结也只是将所学列出，学过之后才感觉几乎毫无用处，所以不学也罢。其他的一些常用功能抽空再做总结。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[instance_eval vs class_eval]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/17/instance-eval-vs-class-eval/"/>
    <updated>2013-09-17T20:54:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/17/instance-eval-vs-class-eval</id>
    <content type="html"><![CDATA[<hr />

<p>Ruby中类其实也是Class的实例。而且instance_eval必须由实例来调用，class_eval必须由类来调用。具体参考下面的实例：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">a</span> <span class="o">=</span> <span class="kp">new</span> <span class="n">A</span>
</span><span class='line'>  <span class="n">a</span><span class="o">.</span><span class="n">instance_eval</span> <span class="k">do</span>
</span><span class='line'>      <span class="nb">self</span> <span class="c1">#=&gt;a</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">def</span> <span class="nf">test</span>
</span><span class='line'>          <span class="nb">puts</span> <span class="s2">&quot;this is a singleton method of instance a&quot;</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">a</span><span class="o">.</span><span class="n">test</span>   <span class="c1">#=&gt;this is a singleton method of instance a</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>  <span class="n">b</span><span class="o">.</span><span class="n">test</span>   <span class="c1">#=&gt;NoMethodError</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>test的receiver为实例a.同时类A本身也是Class类的实例，所以也可以作为instance_eval的receiver，作为该类的singleton method，及常说的类方法，只能通过类名调用。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">A</span><span class="o">.</span><span class="n">instance_eval</span> <span class="k">do</span>
</span><span class='line'>      <span class="k">def</span> <span class="nf">test</span>
</span><span class='line'>          <span class="nb">puts</span> <span class="s2">&quot;this is a singleton method of class A&quot;</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">A</span><span class="o">.</span><span class="n">test</span>  <span class="c1">#=&gt;this is ...</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>而class_eval则receiver则必须为类</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">A</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
</span><span class='line'>      <span class="nb">self</span>  <span class="c1">#=&gt;A</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">def</span> <span class="nf">test</span>
</span><span class='line'>          <span class="nb">puts</span> <span class="s2">&quot;this is a instance method of class A&quot;</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">a</span> <span class="o">=</span> <span class="kp">new</span> <span class="n">A</span>
</span><span class='line'>  <span class="n">a</span><span class="o">.</span><span class="n">test</span>   <span class="c1">#=&gt;this is a instance method of class A</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>class_eval定义的method为类的instance method。</p>

<p>这就是它们二者之间的差别</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更新Octopress]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/17/update-my-blog/"/>
    <updated>2013-09-17T15:22:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/17/update-my-blog</id>
    <content type="html"><![CDATA[<hr />

<p>现在已记不清接触Octopress多长时间了，只依稀记得当时配置Octopress配了好久，然后依然失败，后又忙于其他的事情，所以搭建工作便搁置一旁，七月中旬时间比较充足，所以又开始再次折腾，后来终于搭建成功，所以7.18便发表了第一篇博客。后来一个月之后又开始了我的换肤工作，一切都好，唯一的缺陷是Gravatar的图像没有显示出来，所以便向theme的作者发问，后来也忘了这茬事。就这样又过了一月，直到今天，突然发现我的unread消息里面有几条关于我的message，便打开浏览，才发现作者给的回复，说图像没显示是个bug，现已修复。具体见：</p>

<p><a href="https://github.com/shashankmehta/greyshade/issues/42">https://github.com/shashankmehta/greyshade/issues/42</a></p>

<p>我便立马更新了我的Octopress。更新方法如下：</p>

<pre><code># Get the latest Octopress
git pull octopress master    
# Keep gems updated
bundle install               
# update the template's source
rake update_source            
</code></pre>

<p>具体参考：</p>

<p><a href="http://octopress.org/docs/updating/">http://octopress.org/docs/updating/</a></p>

<p>参考时请务必注意：如果您的octopress主题不是octopress默认主题,请不要执行<code>rake update_style</code>，否则会被还原成默认主题。</p>

<p>本博客采用的主题为：</p>

<p><a href="https://github.com/shashankmehta/greyshade">https://github.com/shashankmehta/greyshade</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建Git服务器]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/17/build-git-remote-repository/"/>
    <updated>2013-09-17T10:54:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/17/build-git-remote-repository</id>
    <content type="html"><![CDATA[<hr />

<p>从开始用Git到现在也已经有一年时间了，但一直都在本地开发，用于管理本地的代码，没有进行多人协作开发，所以也没有必要搭建一个Git服务器。</p>

<p>但就在昨晚，我在教研室给大家介绍Git工具时，感觉大家对这个工具貌似没有太大的热情，猜其原因，可能是因为大家对这个工具过于陌生，而我又讲的太过细节，所以他们可能听得有点烦。但是只有试过之后才能感觉其方便之处，我也希望教研室的同学都能掌握它，所以便决定在教研室搭建一个Git服务器，供大家使用，也思索着今后的项目都用git来进行管理。毕竟现在教研室只有我一人使用git,其他同学都用svn,甚至不用(其实用svn的同学不超过3个)，开发项目也难以统一，而我个人在使用过git后又不想转向svn，同时也非常希望身边的同学也能去使用git这么一个优秀工具，所以只能忽悠他们转向git了。不过经昨晚一役，证明了我忽悠人的本领完全不到家，看来今后得好好练练了。前奏有点过于冗长，下面进入正题吧。</p>

<!-- more -->


<p>由于此次git服务器是搭建在Linux平台，所以首先得有一台安装过Linux的pc,不过幸好我有一台台式机安装了Fedora,这样第一个要素就搞定了。接下来我选择的是ssh来作为git url的协议，因为ssh协议安全方便。所以服务器上还得安装ssh。比较好用的当属openssh了，我此前一直在fedora上用git管理我个人的代码，并且托管在GitHub上，所以这个环节也省了。没有安装的可以试试openssh，具体安装步骤问Google。</p>

<p>当然为了每次对远程库进行操作而不用输入用户名和密码，就需要将本地的公钥拷贝到服务器上对应的文件里，具体步骤如下：</p>

<h3>服务器</h3>

<p>首先为了操作方便安全，需要在服务器上创建一个名为git的用户：</p>

<pre><code>#useradd git
</code></pre>

<p>接着进入到/home/git目录下新建一个.ssh目录,并且需要将.ssh目录group和others的写权限去掉，改为700|744|755皆可,否则ssh远程连接服务器还需要输入密码：</p>

<pre><code>git$ mkdir ~/.ssh
git$ chmod 744 .ssh
</code></pre>

<p>服务端工作暂时完成</p>

<h3>客户端</h3>

<p>进入~/.ssh/目录，生成公钥和密钥：</p>

<pre><code>$ ssh-keygen
</code></pre>

<p>然后一直回车，完成后会发现在~/.ssh目录下多了id_rsa和id_rsa.pub文件，然后将客户端生成的id_rsa.pub公钥拷贝到服务器上：</p>

<pre><code>$scp id_rsa.pub git@your_server_ip/~/.ssh/
</code></pre>

<p>以上操作在~/.ssh目录下进行，git为刚才服务器创建的用户(当然用户名可为其他用户名，只要和服务器对应便可)。此操作完成便会发现服务器上的~/.ssh/目录下多了一个id_rsa.pub文件。</p>

<p>现在转到服务器，将服务器上的~/.ssh目录下的id_rsa.pub文件改为authorized_keys。再重启sshd服务，使配置生效即可。</p>

<p>既然提到服务的开启与关闭，顺带将其操作列出来：</p>

<pre><code>#systemctl start sshd.service     #启动服务
#systemctl stop sshd.service      #关闭服务
#systemctl enable sshd.servie     #使服务开机便自动运行
#systemctl is-enabled sshd.servie #查看服务是否开机启动
#systemctl disable sshd.service   #取消开机自动运行
#systemctl status sshd.service    #查看服务运行状态
#systemctl restart sshd.service   #重启服务
#systemctl reload sshd.service    #重新加载服务配置文件
#systemctl --failed               #显示启动失败的服务
</code></pre>

<h2>SSH无密钥验证原理</h2>

<p>客户端用ssh发起一个ssh连接时，服务端生成一个随机数并用客户端的公钥(保存在authorized_keys中)进行加密，然后发给客户端，客户端用私钥进行解密，并将解密后的数发送给服务端，服务端确认无误后便允许客户端进行连接了。</p>

<p>以上过程的前提是客户端已将公钥保存在服务端的authorized_keys文件中。</p>

<h2>搭建Git服务器</h2>

<p>新建一个文件夹，用来作为Git服务器Repository,然后初始化。如我远程repository文件夹为/home/git/demo/,操作如下：</p>

<pre><code>$mkdir demo    #in /home/git/ directory
$cd ~/demo/
$git init
</code></pre>

<p>然后在客户端添加此远程库，便可进行代码的push和pull了。</p>

<pre><code>$git remote add origin git@your_server_ip:~/demo
#after git add &amp; git commit,run git push
$ git push origin master
</code></pre>

<p>这样就把要管理的代码提交到Git服务器，并用Git来进行管理了。</p>

<p>至此，工作基本完成，后续还有好多东西需要研究，如代码的审查机制等，当然这个功能目前还用不到，但是想了解一下审查机制如何建立，后续再学习吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBox安装ArchLinux系统]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/12/installing-archlinux-in-virtualbox/"/>
    <updated>2013-09-12T22:36:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/12/installing-archlinux-in-virtualbox</id>
    <content type="html"><![CDATA[<hr />

<p>都说ArchLinux很适合折腾，趁今天有时间，就试着安装了一把，不过看ArchLinux的Beginners&rsquo;s Guide，照着其步骤来，结果还是看的云里雾里，看的人头大。便直接上Youtube上找了一个视频，顿时豁然开朗。安装概览如下：</p>

<h2>ArchLinux Install</h2>

<ol>
<li>分区</li>
<li>格式化分区</li>
<li>挂载分区</li>
<li>更改安装镜像</li>
<li>安装基本系统</li>
<li>生成fstab</li>
<li>Chroot到新系统</li>
<li>配置系统</li>
<li>开启网络服务</li>
<li>创建初始化ramdisk环境</li>
<li>设置root密码</li>
<li>安装配置bootloader</li>
<li>卸载分区并重启系统</li>
<li>安装图形用户界面</li>
</ol>


<p>详细步骤如下：</p>

<h3>1. 分区</h3>

<p>虚拟机挂在iso镜像后，然后启动系统，进入后默认进入root提示符，然后输入：</p>

<pre><code>root#cfdisk
</code></pre>

<p>进行分区，一般分三个即可。最后分区结果如下：</p>

<pre><code>dev/sda1 / 8G
dev/sda2 /swap 1G(在空间最后)
dev/sda3 /home 4G
</code></pre>

<p>每个人的分区情况都可能不同，具体依照自己的分区来决定，以下操作都是根据我的分区来进行。</p>

<!-- more -->


<h3>2. 格式化分区</h3>

<p>执行如下命令格式化分区</p>

<pre><code>#mkfs.ext4 /dev/sda1
#mkfs.ext4 /dev/sda3
#mkswap /dev/sda2
#swapon /dev/sda2  #enable swap partion
</code></pre>

<h3>3. 挂载分区</h3>

<pre><code>#mount /dev/sda1 /mnt #mount root partion
#mkdir /mnt/home
#mount /dev/sda3 /mnt/home  #mount home partion
</code></pre>

<h3>4. 更改安装镜像</h3>

<p>镜像列表优先级从上往下，所以为了软件更新的速度，最好将国内的mirror放到最上面。我添加的源及方法如下：</p>

<pre><code>#vi /etc/pacman.d/mirrorlist

Server = http://mirrors.163.com/archlinux/$repo/os/$arch
Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch
Server = http://mirrors.sohu.com/archlinux/$repo/os/$arch
Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch
Server = http://ftp.tku.edu.tw/Linux/ArchLinux/$repo/os/$arch
...
</code></pre>

<h3>5. 安装基本系统</h3>

<p>通过pacstrap脚本安装基本系统，方法如下：</p>

<pre><code>#pacstrap base base-devel
</code></pre>

<h3>6. 生成fstab</h3>

<p>通过下面的命令来生成fstab：</p>

<pre><code>#genfstab /mnt &gt;&gt; /mnt/etc/fstab
</code></pre>

<h3>7. Chroot到新系统</h3>

<p>通过以下命令chroot到新安装的系统:</p>

<pre><code>#arch-chroot /mnt
</code></pre>

<p>使用chroot后，系统的目录结构将以指定的位置作为&#8221;/&ldquo;目录</p>

<h3>8. 配置系统</h3>

<p>系统的配置主要有locale和时区的配置。</p>

<ul>
<li>Locale</li>
</ul>


<p>配置方法如下：</p>

<pre><code>#vi /etc/locale.gen
#locale-gen
</code></pre>

<ul>
<li>配置时区</li>
</ul>


<p>系统默认是utc时区，我们需要换到utc+8时区，方法如下：</p>

<pre><code>#ln s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>

<h3>9. 开启网络服务</h3>

<p>先通过ping命令查看网络是否正常，如果不能上网，则需要配置，方法有两种：1.dhcp  2.static ip。我用的是dhcp，所以只需要开启dhcp服务,方法如下：</p>

<pre><code>#dhcpcd interface_name
</code></pre>

<p>其中interface_name可以通过ifconfig或者ip addr查询。默认在虚拟机中便可上网，所以无需配置。但是安装完成重启系统后便不能上网，原因是dhcp服务没启动。(这是我所碰到的情况)</p>

<h3>10. 创建初始化ramdisk环境</h3>

<p>ramdisk是通过软件将一部分内存(RAM)来模拟一个硬盘，提高访问速度。当然这只是针对内存过剩的情况下才使用，一般完全没有必要。如果您觉得内存完全用不完，为了有效的利用，可以创建ramdisk，毕竟RAM的访问速度非常快，差不多是固态硬盘的30倍。创建ramdisk的方法如下：</p>

<pre><code>    #mkinitcpio -p linux
</code></pre>

<p>通过<code>#vi /etc/mkinitcpio.conf</code>来查看相应的配置信息。</p>

<h3>11. 设置root密码</h3>

<p>设置密码的命令都通用:</p>

<pre><code>#passwd
</code></pre>

<p>然后输入符合要求的密码即可。当然平时操作尽量不要用root,所以为此可以新建一个用户。</p>

<h3>12. 安装配置bootloader</h3>

<p>根据主板BIOS类型不同，安装和配置bootloader的方式也不同。
大致有两种类型：</p>

<ol>
<li>传统的BIOS

<ul>
<li>Syslinux</li>
<li>Grub</li>
</ul>
</li>
<li>UEFI BIOS

<ul>
<li>EFISTUB</li>
<li>Gummiboot</li>
<li>Grub</li>
</ul>
</li>
</ol>


<p>我的主板是传统BIOS类型，采用Grub bootloader。二者的差别见图：</p>

<p><img src="http://pic.yupoo.com/xautjzd/D9TU14LM/medish.jpg" alt="" /></p>

<p>与传统BIOS相比，UEFI BIOS少了BIOS自检功能，这样节省了大量时间，从而加快平台的启动。</p>

<p>安装方法如下：</p>

<pre><code>#pacman -S grub-bios  #install grub bootloader
#grub-install /dev/sda
#grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>

<p>其中grub-install将grub images拷贝到/boot/grub。
grub-mkconfig生成grub的配置，通过-o参数将配置输出到指定的配置文件，默认输出到标准输出。</p>

<h3>13. 卸载分区并重启系统</h3>

<p>卸载分区前先通过<code>#exit</code>退出刚才新安装的系统，然后通过以下方法卸载分区:</p>

<pre><code>#umount /mnt/home
#umount /mnt
</code></pre>

<p>然后通过<code>#reboot</code>重启系统。</p>

<h3>14. 安装图形用户界面</h3>

<p>先确定能否联网：#ping www.google.com,如不能，则查看dhcp服务是否已经开启，可通过<code>dhcpcd interface_name</code>开启。在确保能上网的前提下通过：</p>

<pre><code>#pacman -S gnome xorg
</code></pre>

<p>安装gnome图形用户界面。</p>

<p>经过以上步骤，基本的安装便可完成。我也是安装了好几遍之后才对其安装过程有了大致的了解，写此篇博客的目的主要是为了记录自己的安装过程供今后参考、锻炼自己的写作水平和分享给那些安装ArchLinux过程中碰到问题的朋友参考。</p>

<h3>参考资料</h3>

<ol>
<li><p><a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide">ArchLinux新手指南</a></p></li>
<li><p>Youtube ArchLinux安装视频</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cookies vs Sessions]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/09/cookies-vs-sessions/"/>
    <updated>2013-09-09T10:37:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/09/cookies-vs-sessions</id>
    <content type="html"><![CDATA[<hr />

<p>Http是无状态的协议，客户端给服务器发送请求，服务端响应客户端的请求，会话结束。这样两次会话间不便没有任何关联。但有时候需要在会话间进行信息共享，如：购物车，保存用户名与密码等。为此，cookie与session便诞生了,它们的存在就是为了弥补http协议无状态的缺陷。</p>

<p>cookie与session最大的不同是：cookie保存在用户的浏览器中，而session则保留在服务端。正是这种不同决定了它们的不用使用场合。</p>

<h2>Cookie</h2>

<hr />

<p>cookie机制是通过扩展http协议来实现的。服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。其实纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器端。</p>

<p>cookie主要内容包括：Name,Content,Path,Domain,Expires(过期时间)等。Domain与Path一起构成cookie的作用范围。</p>

<p>若不设置Expires,则默认的cookie生命周期为浏览器会话期间，一旦浏览器关闭，cookie则会被清理掉，这种生命周期为浏览器会话期的cookie被成为会话cookie。会话cookie存储在内存中而不是在硬盘上。</p>

<p>若设置了Expires,浏览器则会把生成的cookie保存在硬盘上，即使浏览器关闭后再打开，cookie依然有效，直至超过设置的expires。</p>

<p>另外，session大小有限制，一旦浏览器禁用cookie，则采用cookie的购物网站便不能进行购物，所以这时候得用session了。</p>

<!-- more -->


<h2>Session</h2>

<hr />

<p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>

<p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p>

<p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。</p>

<h2>Cookie与Session区别</h2>

<hr />

<ol>
<li>cookie存储在客户端的浏览器中，而session则存储在服务器上。</li>
<li>cookie不安全，可以通过分析本地cookie并进行cookie欺骗，而session则相对比较安全。</li>
<li>session会在服务器上保存一段时间，但当访问量增大，会占用服务器的存储空间，影响服务器的性能，如考虑到减轻服务器的性能，则可以选择cookie。</li>
<li>单个cookie保存的数据不会超过4k。</li>
</ol>


<p>所以，一般将登陆等重要信息采用session保存，而其他信息则采用cookie。</p>

<h2>参考资料</h2>

<hr />

<ol>
<li><a href="http://en.wikipedia.org/wiki/Session_">http://en.wikipedia.org/wiki/Session_</a>(computer_science)</li>
<li><a href="http://en.wikipedia.org/wiki/HTTP_cookie#cite_note-1">http://en.wikipedia.org/wiki/HTTP_cookie#cite_note-1</a></li>
<li><a href="http://www.cnblogs.com/shiyangxt/articles/1305506.html">http://www.cnblogs.com/shiyangxt/articles/1305506.html</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
