<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Xautjzd]]></title>
  <link href="http://xautjzd.github.io/atom.xml" rel="self"/>
  <link href="http://xautjzd.github.io/"/>
  <updated>2014-04-15T17:59:09+08:00</updated>
  <id>http://xautjzd.github.io/</id>
  <author>
    <name><![CDATA[xautjzd]]></name>
    <email><![CDATA[xautjzd@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[随时随地用Octopress写博客]]></title>
    <link href="http://xautjzd.github.io/blog/2014/04/01/clone-your-cotopress-to-different-places/"/>
    <updated>2014-04-01T11:00:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2014/04/01/clone-your-cotopress-to-different-places</id>
    <content type="html"><![CDATA[<p><img src="http://xautjzd.github.io/images/20140401octopress.jpg"></p>

<p><a href="http://octopress.org/">Octopress</a>所依赖的环境是Ruby和Git,所以要使用它写博客，必须先确保目标机器上已经安装Ruby和Git。有时候可能需要在新的环境中创作，那么得进行以下的一些操作了。在讲操作前先简要介绍下Octopress如何工作。</p>

<h2>Octopress是怎么工作的?</h2>

<p>Octopress默认有两个分支，即master和source。source分支主要存储用于生成博客的源文件，而master分支则主要包含生成后的博客。master分支存储在_deploy文件夹中，之所以以下划线命名，是因为在执行<code>git push origin source</code>时，下划线开头的文件夹会被忽略掉。</p>

<p>当然，也可以创建自己的分支，但master分支一般主要用于存储生成后的博客，而博客源文件则可以自己新建分支存储。我目前在原有的基础上新建了newtheme分支，用于更改主题后的博客源码存储，以前的源码存储在source分支。</p>

<h2>创建本地Octopress库</h2>

<p>在新环境中写作时，需要进行以下几个步骤：</p>

<!-- more -->


<h3>克隆博客到新机器</h3>

<p>首先，需要克隆source分支到新机器上:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone -b source git@github.com:username/usename.github.com.git Octopress</span></code></pre></td></tr></table></div></figure>


<h3>设置GitHub Repository</h3>

<p>克隆source到本地后，默认没有<em>deploy目录，所以还需要创建</em>deploy，进行git init操作，同时也要设置remote respository。这几个步骤可以通过手动完成，但作为使用者，当然是操作越简单越好，能够自动化完成就自动化。这里Octopress提供了一个自动化完成这几个步骤的脚本，执行它即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>在出现的提示符后输入自己对应的remote repository即可。</p>

<p>以上操作即可完成remote repository的设置，另一种方法是直接克隆master分支到本地：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd Octopress
</span><span class='line'>$ git clone git@github.com:username/username.github.com.git _deploy</span></code></pre></td></tr></table></div></figure>


<p>接下来就是安心写作的时刻了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git远程分支的一些操作]]></title>
    <link href="http://xautjzd.github.io/blog/2014/04/01/some-operation-on-git-branch/"/>
    <updated>2014-04-01T08:52:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2014/04/01/some-operation-on-git-branch</id>
    <content type="html"><![CDATA[<p><img src="http://xautjzd.github.io/images/20140401.jpg"></p>

<p>我是个爱折腾的人，昨天晚上突然看着自己的博客主题不爽，便立马将其从原先的Greyshade换到现在的Cleanpress。换完并构思一篇新博客之后，再次提交到GitHub上，得到提示此分支滞后于GitHub上，采用<code>git pull</code>又产生了太多冲突，冲突少手动解决还可，太多更改起来太麻烦，便萌生推掉远程分支重新提交的念头。可之前从未对远程分支做过相关的操作，只是偶尔删除远程库上的单个文件而已，又不得不求助Google了。碰到问题在解决过程中总是会学到很多，并且记忆深刻，现予以记录，方便自己，也回馈社会。</p>

<p>删除之前先查看远程分支，在确定的情况下再作删除，以致不会删错。</p>

<h2>查看远程分支</h2>

<p>采用<code>git branch -a</code>可查看所有的分支(本地+远程),而<code>git branch -r</code>仅显示远程。如果打开颜色支持，还会看到远程分支的颜色与本地不同。</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$git branch -a
</span><span class='line'>* newtheme
</span><span class='line'>  source
</span><span class='line'>  remotes/origin/HEAD -&gt; origin/master
</span><span class='line'>  remotes/origin/newtheme
</span><span class='line'>  remotes/origin/source
</span></code></pre></td></tr></table></div></figure>


<h2>删除远程分支</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$git push origin --delete &lt;branchname&gt;</span></code></pre></td></tr></table></div></figure>


<p>删除tag也是同样的操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$git push origin --delete &lt;tagname&gt; </span></code></pre></td></tr></table></div></figure>


<p>由于我删除的是远程库的默认分支master,所以在删除过程中产生了以下错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>remote: error: refusing to delete the current branch: refs/heads/master
</span><span class='line'>To git@github.com:xautjzd/xautjzd.github.com.git
</span><span class='line'> ! [remote rejected] master (deletion of the current branch prohibited)
</span><span class='line'>  error: failed to push some refs to 'git@github.com:xautjzd/xautjzd.github.com.git'
</span></code></pre></td></tr></table></div></figure>


<p>这时只要进入该项目的settings，将default branch改为其他分支便可进行删除工作。</p>

<h2>重命名远程分支</h2>

<p>将本地分支推送到一个不存在的远程分支上便可新建远程分支，推送过后发现名称不对，便可通过下面的命令来修改名称：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$git branch -m oldname newname</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有关安卓刷机的一些感受]]></title>
    <link href="http://xautjzd.github.io/blog/2014/03/30/experience-on-android-device-ruu/"/>
    <updated>2014-03-30T21:10:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2014/03/30/experience-on-android-device-ruu</id>
    <content type="html"><![CDATA[<p><img src="http://xautjzd.github.io/images/20140330.jpg">
生命的乐趣在于体验各种新奇，每次尝试都会从中收获兴奋和快乐，同时也会有小小的成就感。但伴随这些快乐的往往是挫折，所以偷偷乐的同时也要正确看待这些不愉快的成分，其实他们就是生活的调味品，在充斥欢乐的时候来点不和谐的东西往往让人记忆深刻，生活需要刺激。</p>

<p>平时一直都处于神游迷离的状态，突然脑中会闪过一丝新奇想法。这不前几天玩三国杀玩到吐的时候，突然闪过刷机的念头，于是在晚上将近12点的时刻，开始了刷机之旅。网上有关各种机型的刷机教程早已铺天盖地，随处可见，也有刷机过程时出现的各种问题。我也将加入这一行列，成为其中一员。</p>

<!-- more -->


<p>首先，在网上找到我的机型(酷派5891)对应的刷机包，然后安装对应的ADB驱动，刷入第三方Recovery，紧接着就是卡刷MIUI&hellip;一切都遵照教程步骤一步一步来，但刷了两次都没成功。最后突然发现刷Recovery时，每次都会提示&#8221;su permission denied&#8221;,但此提示后又出现Recovery刷入成功的提示。虽然开始就看到这提示，但由于看到后面的刷入成功的提示符，所以没太在意，但经过两次失败后，不得不重新审视这些错误了。既然提示权限不够，便抱着试试的心态先进行Root。没想到Root后再进行刷机一路畅通，这算是意外的惊喜吧，看到成功刷成MIUI,心里还是有小小的欣喜的。在这里说句题外话，MIUI确实不错，不论从外观到实用性，都给了我不少惊喜，虽然以前身边的同学也有用小米的，也把玩过，但丝毫没有那种眼前一亮的感觉，有些东西只有亲身体会，并细细观赏才能发现惊喜之处。</p>

<p>完成之后，玩了将近有两个小时吧，大部分的功能都体验了一把，还特意把玩机手册里的大部分内容读了一遍。在体验的过程中，发现一个问题：3g无法上网！这真的是大问题，有种立马想刷回官方酷派自身CoolLife的冲动。网上找了各种解决办法，有说摁<code>*#*#4636#*#*</code>,然后在弹出的界面中配置网络什么的，但都行不通。最后尝试了一个不太可能的解决办法：</p>

<blockquote><p>在关掉3G网络的情况下重启手机</p></blockquote>

<p>没想到成功解决！生活之中处处充满惊喜，往往不可能会变为可能。所以不要轻易放过一丝可能的机会。</p>

<p>刷完第二天，已毕业的师兄过来了，我抱着再次回味的心态又把他的华为C8815刷成MIUI了，虽然刷机过程中出现了小插曲(据说华为和HTC刷机需要先解锁才能刷，但发现解锁过程中无论如何都不弹出输入解锁码的界面。于是放弃解锁的念头直接刷成功了，但唯一的缺陷就是每次重启后,第三方Recovery会给出警告。所以在刷成功后又刷入官方的Recovery了)，但是最终还是成功完成。</p>

<p>以下是我刷机过程的一些疑问：</p>

<ol>
<li>Recovery是什么？</li>
<li>刷机方法有哪些？</li>
<li>Fastboot是什么?</li>
</ol>


<p>可能我有强迫症吧，对于陌生的名词，我不习惯忽略，而是征服它，而Google往往是最有效的查找扫盲方案的工具。以下摘自知乎的答案：</p>

<blockquote><p>Recovery本质是一个简单的Linux+简单的GUI。作用是系统出现问题时，可以切换到Recovery中加载存储卡里面已经下载好的内核，类似PC的U盘修复盘。刷机包通常放在SD卡，所以这种刷机方式一般称为卡刷。</p>

<p>Fastboot主要是用来与Bootloader的USB进行通讯的PC命令行工具，一般主要用来向Bootloader传送刷机文件进行文件分区重烧。在使用时，必须有一根USB线与PC相连，所以这种方式被称为线刷。</p>

<p>卡刷与线刷更为通俗的解释是：fastboot相当于BIOS里面启用CDROM装系统，而Recovery相当于一键Ghost。而Bootloader的解锁就是曲调fastboot指令里的校验模块。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言中的Segment fault问题]]></title>
    <link href="http://xautjzd.github.io/blog/2014/03/15/segment-fault-core-dumped-of-c/"/>
    <updated>2014-03-15T20:47:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2014/03/15/segment-fault-core-dumped-of-c</id>
    <content type="html"><![CDATA[<p><img src="http://xautjzd.github.io/images/20140315.jpg"></p>

<h2>什么是Segment fault?</h2>

<blockquote><p> a segmentation fault (often shortened to segfault) or access violation is a fault raised by hardware with memory protection, notifying an operating system (OS) about a memory access violation; on x86 computers this is a form of general protection fault.</p></blockquote>

<p>以上为<a href="http://en.wikipedia.org/wiki/Segmentation_fault">Wikipedia</a>对段错误的解释。用通俗易懂的话来说就是访问越界，访问了不存在或者受操作系统保护的内存，通常都是由于数组越界或者指针引起。</p>

<h2>产生段错误的原因</h2>

<ol>
<li>dereferencing NULL</li>
<li>dereferencing an uninitialized pointer</li>
<li>deferencing a pointer that has been freed/out of scope</li>
<li>writing off the end of an array</li>
<li>recursive function that uses all of the stack space</li>
</ol>


<!-- more -->


<h2>什么是core文件？</h2>

<p>在调试段错误前，不得不提到core文件。那么什么是core文件呢?core文件其实就是当程序崩溃时保存的该进程在内存中的映像(同时包含调试信息),主要用于调试。</p>

<h2>如何调试？</h2>

<p>像VS等IDE集成度太高，在方便快捷的同时也会将人培养成傻瓜，培养成码农。所以要想抱着以学习的心态来学习，最好转到Linux/Mac OS平台下，通过gcc/cmake等command-line式的编译器来进行代码的编译，当然我这里主要指的是c/c++。</p>

<p>Linux段错误时默认不会生成core file，core file的大小被设置为0,可通过<code>ulimit -a</code>查看。所以首先得通过<code>$ulimit -c unlimited</code>进行设置，以便能够生成core file。但在shell里设置的话，只是针对当前会话有效，如果想永久生效，需要将其写到配置文件中，如~/.bashrc, /etc/profile/, /etc/security/limits.conf等中。</p>

<p>设置完成后，便可通过gdb和gcc来调试程序了。如果一个程序存在段错误问题，那么执行<code>$gcc filename.c -g -o filename</code>进行编译后，在运行<code>filename</code>的时候，会在当前的目录下产生一个core文件。那么这个时候便可以利用core文件进行调试了。调试方法为:</p>

<pre><code>$gdb [exec file] [core file]
</code></pre>

<p>有关gdb的详细用法，请参考相关文档去吧。</p>

<p>段错误实质上是操作系统内核产生的一种中断信号，信号为12。有关信号的知识，请参考操作系统相关的书籍。可通过<code>kill -s SIGSEGV processid</code>来给指定的进程id发送段错误信号，段错误默认处理方法是终止程序的运行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014西安归途随笔]]></title>
    <link href="http://xautjzd.github.io/blog/2014/02/13/back-to-xian-2014/"/>
    <updated>2014-02-13T07:32:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2014/02/13/back-to-xian-2014</id>
    <content type="html"><![CDATA[<p><img src="http://xautjzd.github.io/images/back_to_xi'an20140213.jpg"></p>

<p>从1月20号到现在已有20多天了，说长不长，说短不短。回家的这段日子里很惬意，每天睡觉睡到自然醒，吃就更不用说了，无论在哪都不及家里吃的放心舒心，至于住么，家里自然比学校宿舍舒服多了。唯一美中不足的就是缺乏学习的氛围，不管多闲，都没心思整理开题报告，学习便更不用说了。一开始将其归结于家里没网，不过仔细琢磨下还是学习的气氛不够，导致自己变得懒惰。幸好在家呆的时间不是很长，不然真的要懒得无以复加。</p>

<p>本来回去之前便已将回程票买好了，买的2.16的，从武昌走。原计划是提前去武汉玩两天再走，毕竟武汉哥们好几个，随意蹭个吃住不成问题。哪知导师开始催(其实也谈不上催，就QQ上发了一个他专署的?而已，顿时感觉情况不妙，赶紧问问教研室的同学，没想到同级的都去了好几个，而且老师前几天给他们说了句：研究生应该过完初十就来的，这。。。不敢久留，立马抢了张12号的票)，便匆匆踏上了回西安的旅途。</p>

<!-- more -->


<p>以往都是从武昌走，因为哥们几个都留在武昌那边。匆忙踏上归途，当然选择汉口了，毕竟汉口这边还是近点。但汉口火车站有点陌生，生怕走错了，便格外小心谨慎(虽然以前从汉口走过一次，不过已经事隔好几年了)。几年没从这边走，发现变化真的还挺大。火车站的地下一层就是出租、地铁、公交和大巴的起点，简直是太方便了！对比下西安，就差的有点远了。西安火车站相比之下显得有点小，有点陈旧。</p>

<p>回程中，对面座的是甘肃陇西的一对夫妇，车上闲聊了几句，才知道他们是在武汉开拉面馆的陇西人。这对夫妇过年没有回家，现在才回。只是他们此次回去就不再准备再返回武汉，具体原因没好意思问。但我想最可能的是生意不好，赚不到钱吧。因为武汉那边的饮食主要是米饭，中午下午吃拉面不太可能。早餐也吃热干面居多，当然可能也有不乏吃其他面的，比如拉面，但相比之下，拉面的价格有点高(他们说大碗6元，小碗5元)这对于早餐来说略贵，不划算。不过兰州拉面真的是名声在外，全国人民几乎无人不知无人不晓。看他们穿着应该是回民，因为男的头上带着一顶小白帽，女的头上搭着一块紫色的头巾，这是回民特有的标志，当然至少我是这么认为，至于甘肃有没有不是回民也这身打扮那就不得而知了。他们的笑很纯朴，没有城市中人们透漏出的那种精明和虚伪等。在车上时，我真的很想问问他们为何这身打扮，有什么特别的意义。但好几次都是话到嘴边都咽下去了，生怕会显得不礼貌或引起麻烦等。毕竟问这问题有点像问人为什么要穿衣似的，太习以为常，那种穿着早已渗透到他们的潜意识当中。不过我用手机查了查，有的网友说是男的带的帽子是圆形的或者是六角形，而女的则是结婚后才系头巾，未婚女子则不必要，头巾有黑色、白色等。年龄不同，佩戴的颜色会有所不同，不过我见过的只有黑色和紫色，等哪天有个回民朋友再详细了解下他们的风俗吧，我还是对各种不同的民俗颇有兴趣，从吃到穿到节日都是我的主要关注点。</p>

<p>就这样随着时间的流逝，我也到站了，列车抵达西安是凌晨5点多，公交是6点才发车。趁等车时刻，发现西安的出租公司竟有10家左右。以前印象中只有4-5种，没想到在火车站附近竟有那么多。西安其他地方相信也应该会有我没看到过的，可见出租很赚钱啊。就这样又一次见证了西安天未亮的时刻，毕竟这样的时刻对于我并不多见。将行李放到宿舍，去同盛楼吃了一碗肉丸糊辣汤，真心有点坑爹，6块吃了个这玩意儿。</p>

<p>另一个不得不提的是网络资费问题。现在是移动互联网的时代，手机上网成了人们必不可少的一项休闲活动。各种APP都需要网络才能玩的转，所以没有流量怎么能行？套餐送的流量为300M，但都是省内的，这对于省外的求学者来说有点令人心寒。网还得上，打电话给客服办个流量包，结果得知当月办只能当月使用，这真的是有点无语，1月底你说我办还是不办？为何这么死板，为何不按照从生效日起一个月呢？这样不是皆大欢喜么？闹心的很。</p>

<p>2014西安回程随笔到此结束吧，我的马年每周千字工作拉开序幕了，接下来的就是需要坚持了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim插件之surround.vim]]></title>
    <link href="http://xautjzd.github.io/blog/2014/01/16/vim-plugin-surround-dot-vim/"/>
    <updated>2014-01-16T10:17:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2014/01/16/vim-plugin-surround-dot-vim</id>
    <content type="html"><![CDATA[<h3>Surround.vim插件简介</h3>

<p><a href="https://github.com/tpope/vim-surround">Surround.vim</a> 是一款关于括号、引号和xml标签匹配的插件，可以成对的添加、修改和删除。当然也可以自定义匹配项。下面就常用的功能分别对标记的添加、修改和删除一一介绍。</p>

<h4>添加</h4>

<p>如现有一文本<code>Hello,wolrd</code>。光标处在文本中，然后输入ysiw&#8221;,文本变成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"Hello,world"</span></code></pre></td></tr></table></div></figure>


<p><code>yss</code>则将光标所在的当前行全部添加标签。如<code>yss)</code>则将当前行用()包围。</p>

<!-- more -->


<p>b, B, r和a分别是), }, ]和>的别名，t 则代表html/xml标签。</p>

<p><code>ysst</code>,然后再输入html/xml标签，即可成对添加。如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Hello,world</span></code></pre></td></tr></table></div></figure>


<p>输入<code>ysst&lt;p&gt;</code>后，变为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;p&gt;Hello,World&lt;/p&gt;</span></code></pre></td></tr></table></div></figure>


<p>类似的，<code>yssb</code>、<code>yssB</code>、<code>yssr</code>和<code>yssa</code>则给当前行添加相应的标记。</p>

<p><code>&lt;Ctrl-v&gt;ySb</code>则给选定的文本添加()。</p>

<h4>修改</h4>

<p><code>cs</code>为修改的命令。如：<code>cs)}</code>将()换为{}，<code>csbr</code>将()换为[]。</p>

<h4>删除</h4>

<p><code>ds</code>为删除的命令。如：<code>dsb</code>删除(),<code>dsB</code>删除{},<code>dst</code>则删除相应的html/xml标签。</p>

<h3>安装</h3>

<p>先安装上<a href="https://github.com/gmarik/vundle">vundle</a>或者<a href="https://github.com/tpope/vim-pathogen">pathogen</a>插件，然后再通过他们安装插件比较方便。下面以vundle举例：</p>

<p>在<a href="https://github.com/xautjzd/dotvim">~/.vimrc</a>中添加：</p>

<p>Bundle &lsquo;tpope/vim-surround&rsquo;</p>

<p>然后执行<code>BundleInstall</code>安装。</p>

<p>更多关于surround的细节，请通过<code>：help surround</code>查看。</p>

<h3>其他</h3>

<p>其实surround只是对vim中<a href="http://vimdoc.sourceforge.net/htmldoc/motion.html">text-object motion</a>的扩展，vim常见的text-object编辑功能有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ci(, ci[, ci{：删除(),[],{}之间的所有字符并进入insert模式。类似的还有ci",ci'。
</span><span class='line'>cit: 删除html/xml标签内所有的文本并进入insert模式。
</span><span class='line'>di: 剪切配对符号间的文本，eg:di(, di{, ...
</span><span class='line'>yi: 复制配对符号间的文本, eg:yi(, yi{, ...
</span><span class='line'>
</span><span class='line'>ca, da, ya与ci, di, yi类似，只是包括比配符号本身。</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回首2013，展望2014]]></title>
    <link href="http://xautjzd.github.io/blog/2014/01/02/new-year-plan/"/>
    <updated>2014-01-02T14:52:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2014/01/02/new-year-plan</id>
    <content type="html"><![CDATA[<p>回首过去这一年，无论从技术还是思维上，都有很大的提升，但要我数萝卜下窖似的列举出来，我还真的列不出。只清楚地记得以下几件大事：</p>

<ol>
<li>将博客从CSDN迁移到Octopress上。之所以迁移到Octopress上，是因为Octopress基于Jekyll，而Jekyll采用Ruby语言实现，恰巧我又迷上了Ruby。另一个原因是Octopress采用Markdown语法实现，排版更方便，简单的几个符号便能搞定,而且更美观。自从用了Markdown语法排版后，腰不酸了，腿不疼了。剩余的时间则可投入写作，何乐而不为呢?最大的好处是易迁移，只不过现在暂时还没有切身的体会，想想罢了，毕竟托管到GitHub上对于目前阶段已经够用，不必花钱买VPS，但不排除以后有钱了弄个VPS折腾下。那时候迁移也方便，所有的博客都是通过Jekyll引擎将markdown格式的文本转换为静态的Html文档，简单的拷贝下便可以了，而且还可以很方便的进行备份。其实与他人协作共同管理博客也是轻而易举的事了，只不过目前没这必要。</li>
</ol>


<!-- more -->


<ol>
<li><p>加入了西安Rubyists圈子，结识了好几个大哥，编程都很猛。在他们的熏陶下，了解了不少新知识，拓宽了知识面，同时也见识了有趣的工具。这也算是从学校这个小圈子走出去了，跳出圈子后，才发现自己有多菜，真的是被甩好几条街。在学校里面，觉得自己水平还行，正是这种井底之蛙的思维严重束缚了自己，以为比身边同学多了解一点就很有成就感。出去一看，完全不是那么回事。如果说别人是高中生，那么我感觉自己就是小学生。</p></li>
<li><p>成了工具控。现在已经习惯使用Vim进行编写代码和写博客，但现在写过的也仅限于C、Java、Ruby与Shell脚本了。如果说从前的Vim在我手中是把未经开封的盾刀的话，那么如今它已是寒气逼人。以前用它也仅限于插入、移动、保存等基本功能，在2013年里，我已经学会了打磨它，为它装上各种犀利插件，使其锋利起来，正所谓磨刀不误砍柴工。同时也在这一年习惯了Evernote的使用，最早接触它应该是在11年末，不过当时也没给人眼睛一亮的感觉，记得当时用的还是盛大的麦库笔记本。经过了差不多一年的时间，已经逐渐成为我的必备工具了。相比其他记事本来说，最吸引人之处当属它的Web Clipper插件，从此以后看到好文只需单击一下鼠标便可收入囊中，不用在复制粘贴，而且还担心排版问题。另一个强大的存储工具——Dropbox也不得不提，作为同步网盘，确实好用的没话说。国内的类似同步网盘也有不少，空间可能更大，但是用户体验性却始终不如网盘的鼻祖——Dropbox，它的差异备份应该算是其一大特色，其他不少网盘只能望其项背。</p></li>
<li><p>一月至少一本书的计划顺利坚持下来。具体忘了从几月份开始这个计划了，不过从实施至今确实一直坚持下来了，看过的书有《黑客与画家》，《浪潮之颠》，《水知道答案》，《生命中不能承受的轻》，《Programming Ruby》,《Ruby元编程》，《Rework》,《Unix环境高级编程》，《深入理解计算机系统》，《高效程序员的45个习惯》，《七周七语言》等，至少80%以上都是与IT行业有关，文学方面大致看过的只是龙应台女士的《野火集》、《目送》等几本散文集，还有所欠缺。不过也庆幸至少坚持下来了，希望在2014年继续，直至我生命的尽头。</p></li>
<li><p>Linux水平较之去年有提升，尤其在Shell编程方面，在这里不得不提到《Linux Shell脚本攻略》这本书了，知识的组织确实非常巧妙，从原理到实战，讲的清晰到位。对于Git的理解也更深入，不限于以前仅了解的add,commit,reset，log等几个基本操作。目前比较熟悉的是Debian和Red Hat系的系统，ArchLinux只是体验了一把，花了一天研究了下，后来也没再继续研究下去，现在也忘的差不多了，头脑中多了几个名词而已。</p></li>
<li><p>由于老师的安排，从11月开始便开始研究起了Hadoop，前前后后大致花了3周时间，后来由于其他原因也搁置了。Hadoop的环境不是很好配置，光环境的搭建就花了好几天时间。程序更是难以理解，花了差不多一周多的时间才大致明白程序的结构及运行原理，与传统的程序出入有点大，调试也不是那么容易，后来虽说没再继续，不过也算是对Hadoop有了基本的认识。12月份开始便开始为开题做准备，开始看论文资料，大多都是与云计算有关，特别是云迁移方面，最后逐渐向移动设备的云迁移靠拢，同时也看了几篇行为识别方面的论文，所以最后题目定为《移动云迁移的行为识别应用研究》，真的是为开题发愁，之前都是开发web相关的应用，现在突然走起了理论流，真心不太适应。特别是看英文论文，虽说大致能看懂，但效率还是比较低，须全身心的投入才能投入其中，稍有浮躁，便两眼发黑。</p></li>
</ol>


<p>回首2013，大致也就对这几件事印象比较深刻，其他的都已经被时间之尘所掩埋。穿梭于各种博客间，发现都在展望2014，我也要跟上队伍，不掉队，来展望下我的2014。希望在2014年里，以下几点能实现：</p>

<ol>
<li><p>拿到驾照。虽然报名一年多了，但除了考了科一外，根本没去练过车，实属遗憾。其实不是没有时间，只是自己一直在找借口自己好忙，没时间去，便也耽误了。</p></li>
<li><p>提高执行力。想到的事尽早完成，尽量养成“今日事，今日毕”的习惯。</p></li>
<li><p>找到理想的工作，争取进BAT其中一家。2014年下半年便要开始找工作，所以上半年得开始做准备。</p></li>
<li><p>解决单身问题。虽说这得讲求缘分，不过还是尽早完成吧。</p></li>
<li><p>坚持one book one month at least计划</p></li>
<li><p>开始强身健体。干程序员这行，不仅拼智力，还得拼体力，身体不好，怎么干这行。现在发现自己的肩已经太过僵硬，不够灵活，希望在新的一年里多锻炼，每天坚持跑步。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tmux常用操作总结]]></title>
    <link href="http://xautjzd.github.io/blog/2013/12/04/sumary-about-tmux-operation/"/>
    <updated>2013-12-04T19:32:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/12/04/sumary-about-tmux-operation</id>
    <content type="html"><![CDATA[<p>以前也写过一篇关于<a href="http://xautjzd.github.io/blog/2013/08/08/tmux-use-and-configuration/">tmux的文章</a>,大概对tmux从简介、安装到操作已有简单的介绍，但由于是刚使用tmux时所写，总感觉操作部分写的不是很好，不够全面，所以便出现了此篇，算是填补前一篇的不足吧。</p>

<p>前边的操作前缀是Ctrl+b组合键，这两个键相隔甚远，操作起来太别扭，后来便在<code>~/.tmux.conf</code>配置文件中更改成<code>Ctrl+a</code>前缀了。具体配置见GitHub上<a href="https://github.com/xautjzd/dotvim">我的tmux配置</a>。</p>

<h3><strong>Tmux常用操作</strong></h3>

<h4>1. 新建Session</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$tmux new -s sessionname</span></code></pre></td></tr></table></div></figure>


<h4>2. 杀死指定Session</h4>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$tmux kill-session sessionname</span></code></pre></td></tr></table></div></figure>


<h4>3. 杀死所有Session</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$tmux kill-server</span></code></pre></td></tr></table></div></figure>


<h4>4. 列出创建的Sessions</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$tmux ls</span></code></pre></td></tr></table></div></figure>


<h4>5. 附加指定Session</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$tmux a -t sessionname</span></code></pre></td></tr></table></div></figure>


<h4>6. 离开Tmux到shell环境</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + d</span></code></pre></td></tr></table></div></figure>


<p><strong>注</strong>：其中prefix即为前边所提到配置好的Ctrl+a(tmux默认为ctrl+b),<code>&lt;prefix&gt; + d</code> 即为Ctrl+a+d三个键的组合。后面如无特别说明，也指这样的键组合。<code>离开tmux环境</code>指的是首先在shell下tmux new -s sessionname进入到tmux环境，然后<code>&lt;prefix&gt; + d</code> 切换到shell环境，在shell下又可以通过<code>tmux a -t sessionname</code>切换到tmux环境。</p>

<p>以下的操作都在tmux环境里面进行：</p>

<h4>7. 新建Window</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + c</span></code></pre></td></tr></table></div></figure>


<h4>8. 水平分屏</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + -</span></code></pre></td></tr></table></div></figure>


<p>默认为&#8221;,需要在~/.tmux.conf中配置</p>

<h4>9. 垂直分屏</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + |</span></code></pre></td></tr></table></div></figure>


<h4>10. 窗口重命名</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + , # 默认为%</span></code></pre></td></tr></table></div></figure>


<h4>11. 窗口切换</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + n  # n为窗口的编号，从0开始，编号可以在屏幕最下方看到</span></code></pre></td></tr></table></div></figure>


<h4>12. 同一窗口中pane之间的切换</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + 方向键</span></code></pre></td></tr></table></div></figure>


<h4>13. 关闭当前窗口中的所有panes</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + !</span></code></pre></td></tr></table></div></figure>


<h4>14. 显示时间</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + t</span></code></pre></td></tr></table></div></figure>


<h4>15. 关闭当前窗口</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + : </span></code></pre></td></tr></table></div></figure>


<p>
然后输入<code>kill-window</code>即可关闭。</p>

<h4>16. 查看帮助文档</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$&lt;prefix&gt; + ?</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拆机过程中的一些收获]]></title>
    <link href="http://xautjzd.github.io/blog/2013/11/23/experience-share-about-computer-disassembly/"/>
    <updated>2013-11-23T10:58:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/11/23/experience-share-about-computer-disassembly</id>
    <content type="html"><![CDATA[<p>昨天吃完午饭后来到教研室，突然师妹说有个远程(其实只是充分利用教研室的旧机器，在上面发布一些教研室的web项目，还有做为版本控制器的服务器)机器现在不能远程了，尝试关机不得所以强关，然后重启便无法启动，而她的数据在上面。所以我便开始了肢解之路。</p>

<p>由于几乎没有拆台式机的经验，所以拆机过程花费时间比较长，尤其是机箱外盖的拆卸。毕竟是旧机器，没有什么拆机教程可供参考，所以只能摸索着前进了，最后还是使用了点暴力手段才卸下的。拆开后，首先看了下是不是由于接口松动导致无法开机(其实连我自己都不相信是接口松动导致，因为强关不可能导致接口松动吧，可能是为了自我安慰才想到是接口松动的缘故)，查看了一番，便很快排除这个原因。突然想强关的后果很可能就是导致硬盘坏掉，但是起码也应该进入BIOS吧。便猜想是不是电源坏掉导致的原因，老师刚好这时候也出来了，看到我在拆着机，便问我什么情况，我便跟老师一五一十地把情况汇报了一番。然后老师便去隔壁(其实是老师所在部门的办公室)找了一台不能用的机器，我拿过来之后卸下电源重新换上去，当然其中还有不少接线的问题还摸索了一阵,最后才发现电源存在的作用：</p>

<!-- more -->


<ol>
<li>给主板供电。虽然主板肯定要供电，但是所知也仅此而已，具体不知道是如何供电的，直到现在才有所真正明白其过程。</li>
<li>给CPU供电。这个是修理完查资料才发现的。由于CPU嵌在主板上，所以一直以为只要给主板供电便可，详情稍后再介绍。</li>
<li>给硬盘供电。</li>
<li>给光驱供电。</li>
</ol>


<p>换上电源后，尝试开机，发现终于可以进BIOS了，但是系统进不去，心想不是硬盘坏了吧，顿时心凉。索幸我手头有U盘做的Linux启动盘，便换上进入了Linux,最后发现可以识别出硬盘，还能看到硬盘里的资料。这时候便放心了，很可能只是系统坏了(如MBR写入有问题之类),便先把C盘里的重要资料拷贝了一份，然后重新装系统的节奏。拿着同学做的老毛桃进入了WinPE，然后加载XP的iso镜像，准备重装系统，发现WinPE不能加载iso(没用WinPE重装过系统，还真不知道能不能加载iso镜像进行系统重装，待会儿再查吧)。但同学说需要gho镜像才行，便趁他下gho之际，我便继续捣鼓着，换sata线、重新换线上其他接口什么的。然后试着再次启动系统，发现能进入，真的不能不说有点诡异，难道这是上帝在我和开玩笑么?接下来便开始了组装，当然组装之前把里面的灰尘给清除了一番，真一个脏字了得！尘飞扬，手如炭，满地灰。</p>

<p>结束后，便开始了查资料之路。因为在拆机过程中发现有不少接口都不认识，而且有些接口也没有接线，即使接线了，也有一些不知道作用。而我又喜欢刨根问底。首先查了下电源的作用，它主要是给硬盘、主板、CPU和光驱供电。</p>

<p>其中，针对IDE接口的硬盘和SATA接口的硬盘其供电的接口也有所不同。以上所说的IDE和SATA是指数据传输的接口。现在硬盘数据传输接口有IDE、SCCI、SATA、MSATA和PCI—E等。IDE口的硬盘现在市面上已经看不到了，以前的机器一般采用IDE，后来慢慢已经转向SATA,当然SATA有SATA1、SATA2和SATA3，外观没区别，只是传输速率有所不同，SATA1理论传输速率为1.5Gbit/s,而SATA2为3Gbit/s，SATA3则为6Gbit/s。SCSI网上资料显示用于工作站、服务器可能比较多点，当然估计也只是针对以前来说的，现在估计也被淘汰了。现在市面上主流还是SATA，而MSATA则主要用于超级本，毕竟超级本外观所限，再用2.5英寸的就不太合适了。PCI-E则是和显卡一样的接口的固态硬盘，至于它而SATA接口的对比没查资料，也不甚清楚。光驱接口也硬盘一致，感觉有点像孪生兄弟一样，同穿一条裤子。所以有些好事者便拆下光驱，再扩一个硬盘，将系统安装再SSD上，开机速度立马有质的提升。</p>

<p>而给主板充电的接口则主要是24pin的接口，通常为白色，兼容以前的20pin。其实多出的4pin主要是给PCI-E(现在有少数SSD也是采用此接口)显卡供电，如果显卡功耗不大，20pin也是没问题的。</p>

<p>CPU供电接口则有8pin和4pin,以前的可能采用4pin，而今可能都换成8pin了。</p>

<p>内存条接口是比较好识别的，主要有DDR2和DDR3,目前DDR3正在逐渐替代DDR2的主流地位。最好区别它们便是查看它们的防呆口。</p>

<p>最后，说下散热的机制吧。以前的散热一般都是通过金属支架和风扇来进行的。看过比较古董的机器内部构造的人可能都会发现里面有一个大金属疙瘩，而且还有很多槽，这便是金属支架了。金属支架有一面和CPU紧贴，并且表面涂有硅脂，硅质的主要作用是导热，而不是起散热功能，这点可能大家有误解(也许是我想多了，我以前听别人说硅脂是散热的，从此头脑中便将二者等价，真不知到底是受了谁的误导，坑了我好几年啊)。硅脂导热性比较好，将CPU表面产生的高温迅速传给金属支架，然后经由支架将热量散走，金属支架对应的风扇也是为了更快更好的散热而设计的。而现在的笔记本散热一般是通过散热管+风扇将热量排走。拆过笔记本的、看过别人拆笔记本的或是见过笔记本内部构造图的都会发现里面有个铜管，而且还比较长，那个就是散热管，里面是真空，存放有水。要知道，真空状态下水的沸点是比较低的(学过物理的应该都知道吧),所以贴近cpu的一端水很快变成水蒸汽，同时将热量带到另一端再冷却成水，再流回去，还有一个辅助铜管散热的风扇，将铜管的热量散发到空气中。</p>

<p>至于其他的一些接口，也就没必要介绍了，因为要么不常用，要么司空见惯。有兴趣，可以自行查资料。勿听一家之言，否则难免会被误导。</p>

<h2>参考资料</h2>

<p><a href="http://sbgl.jdzj.com/tech/201104/20110425123142_71032.html">http://sbgl.jdzj.com/tech/201104/20110425123142_71032.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[放慢脚步回首过去一个月]]></title>
    <link href="http://xautjzd.github.io/blog/2013/11/21/some-ideas/"/>
    <updated>2013-11-21T20:31:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/11/21/some-ideas</id>
    <content type="html"><![CDATA[<p>自上篇文章到现在差不多快一个月了，也因各种琐碎的事情没有闲下来构思一篇博文，顿时有一丝的罪恶感。吃完晚饭洗完澡坐在电脑前突然有种茫然的感觉，上了会儿高端大气的知乎浏览了几个帖子，本想着改下代码，结果发现也打不起精神，便趁此机会来码字来寻求心灵片刻的安宁吧。</p>

<p>首先，说说最近的劳动吧，虽然没啥成果。最近教研室事不多，刚好师姐有个同学需要找人帮忙改个项目，便答应帮忙(当然是有酬劳的，不然也不会闲到改.net的代码，虽然目前还没有谈具体的数字)。其实也不在乎都多少，答应干此活也只是为了积累经验而已，方便日后找工作，同时也算是练手。拿到代码后，我顿时有种欲哭无泪的感觉，代码逻辑及结构之混乱超乎我想象，可以总结为以下几点：</p>

<!-- more -->


<ul>
<li><p>结构混乱，虽然有分层，从下到上大致有DAL、BLL、WebService和Web这几层，然后还有一个Common，里面大致是定义一些通用的操作供DAL调用。但是后来发现代码的逻辑几乎都是在Web层直接进行的，询问得知此系统是在它们以前的OA系统基础上改的，所以保留着以前OA的那种分层结构，只是新开发时没有按照以前的那种分层走。</p></li>
<li><p>命名<strong>极其</strong>糟糕。之所以突出<em>极其</em>二字，是因为它的命名真的已经到了惨不忍睹的地步，有种想撞墙的感觉。我真的怀疑写代码的人知道常见的几种命名法则不，如驼峰命名法、下划线命名法、Pascal命名法和匈牙利命名法(在此提匈牙利命名法，不知道会不会遭人鄙视，之前看到网上已经有太多的人吐槽，连Linus大神也吐槽过)。我个人还是比较青睐于驼峰命名法和下划线命名法，看着很优雅。接着不得不吐槽变量的命名了，一会儿用英文命名，一会儿用对应的拼音，混在一起感觉有点奇葩感。我个人是不太喜欢用拼音，即使不了解，也会用工具将中文翻译成对应的英文再做命名，不知道这算不算强迫症。</p></li>
<li><p>代码逻辑凌乱。逻辑与逻辑间缺少空行分隔，所以有种目不忍视的感觉。还有比较重要的一点是代码重复性太高。比如说省市县三级下拉菜单，很多页面都会用到，但是每个页面都会重复性地写这些代码。如果有机会，我真的会问写此代码的人懂不懂什么叫DRY(Don&rsquo;t Repeat Yourself)，虽然此思想是学习Ruby过程种了解到的，但我觉得可以用于任何语言，放置四海而皆准。毕竟重复性的工作会导致代码的耦合性高，如果今后需要变动，那么每个引用此代码的地方都得做相应修改。</p></li>
<li><p>注释过少。尤其是功能性的注释太少，虽然通过阅读代码最终也能了解，但能不看内部实现便不看，毕竟看代码还是需要花费一定时间的，而且理解可能还会有偏差，所以还是很有必要对代码做相应的功能性注释，不仅方便他人，也方便自己。所以要了解一个人的编码水平，通过观其代码便能略之一二。</p></li>
<li><p>没有使用ORM。我个人也感觉这算是一个弊端，毕竟对于应用开发者来说，效率至上(指开发效率)。虽然直接写Sql语句可能效率更高，但是为此付出的开发时间成本则是不扉，在对性能要求不是很极端的情况下也就显得有些得不偿失。ORM(Object Relationship Mapping)不仅使开发更高效，而且代码也更易阅读，更易维护。反正我了解的应用开发一般都会用到ORM,如.net的EF(Entity Framework),Java的Hibernate、Mybatis等，Ruby的ActiveRecord等。其他语言也应该有相应的ORM,不过不了解，我了解的就是这三门语言，所以也便能说出一二。</p></li>
</ul>


<p>说了这么多弊端，不知道是不是由于我平时的开发一般都是MVC模式，所以对其他的开发模式看不习惯所致。不管怎样，还是得硬着头皮改完吧，既然承诺于人，便得有始有终，这也算是我一贯的办事风格吧。</p>

<p>其次，由于老师让看Hadoop,所以便时不时的看看云计算和Hadoop这块，算法还真不是我的强项，看到朴素贝叶斯和KNN算法，真的是看不下去，尤其用MapReduce实现。MapReduce程序真的是和一般的代码差别有点大，把握不住运行的脉络，一旦看不清脉络，便有种管中窥豹的感觉。身边也没有搞Hadoop的人，想找个人聊聊都困难。网上吧，提的问题太过白痴，也往往遭人鄙夷，从此便被无视。这算是如今最头疼的事了。</p>

<p>最后，说说加入Rubyists的情况吧。2012年，Oschina在西安举办OSC，作为开源的爱好者与拥护者便跑去参加了。正是这次机缘巧合接触了Ruby，接着便花了一些时间去了解Ruby和Rails。在RubyChina社区上又无意看到了一个关于西安Rubyists线下活动的召集贴，便报名参加了，从2013.7第一次参加到现在也差不多5个月了，也就是5次活动(每月一次),要说最大的收获应该就是眼界的拓宽，对IT行业有了一个更深的认识，对新技术也有了一点了解，如angularjs,远程工作的一些工具，同时也更加坚定了自己对Git/GitHub(以前一直都是一个人在使用，身边的同学还没发现使用Git，用了svn都算不错了)及Vim的使用。Vim以前也只是会一些基本操作，配置都是拷贝网上现成的，到现在的熟练运用，可以说也算是有质的飞跃了。虽然目前一直在Rubyists中一直处于索取的状态，不过相信迟早也会奉献的，可以讲讲Vim的操作、配置及常用插件等。</p>

<p>PS:刚在知乎上看到某人专栏上的一篇文章，觉得有部分写的不错，便搬过来吧，当然不是完全照搬，我会结合我自己切身的经历用自己的语言描述出来。大致如下：</p>

<p>由于我所学的专业为计算机，所以我对这一领域有找寻答案的能力，因此在碰到问题时能很快的定位答案，予以解决，真的可谓时见招拆招。如果换作非计算机专业的人来说，可能显得稍微吃力。当一个人想知道[门]背后有什么的时候，他需要的只是开启门的钥匙，而这个钥匙刚好在我手里，因为即使我也不知道门背后有什么，但我却能够将门打开，让大家看到这门背后到底是什么。而帮人解决问题的过程则让我了解门背后的东西，还收获了开启各种门的方法。</p>

<p>我以前老喜欢上网浏览信息，比如说CSDN、新浪微博、RubyChina等，但慢慢这种趋势有所下降。因为我感觉看的东西再多，慢慢也便淡忘，从上面所了解的知识再丰富、再专业，也不过是碎片化的，不会提供一个系统的知识，所以也便不可能形成完整的知识结构。没有一个完整的知识结构，知识储备便很难有质的突破。所以我也慢慢更多地转向了书本的学习，毕竟从书本上看的东西还是比较系统化。</p>

<p>最近在阅读的一本书是《高效程序员的45个习惯》，真心值得一读。身处碎片化的时代，能够静下心来读一本书真的很不容易。希望接下来的日子里能将看微博、豆瓣等时间更多的分给读书。不知不觉已经10点多了，就这样断断续续的竟写了三个小时，到此结束吧，也算是最自己近一个月来的总结。不认识过去，便看不清未来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim寄存器]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/27/vim-registers/"/>
    <updated>2013-10-27T16:37:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/27/vim-registers</id>
    <content type="html"><![CDATA[<p>谈Vim寄存器前先对昨天做个总结吧。Rails Girls昨天在西安的ThoughtWorks成功举办，目的是帮女性程序员了解Ruby &amp; Rails，报名参加的学员大概有30多人，教练大致有10来个，由于活动是ThoughtWorks和西安的Rubyists一起合作举办，所以我作为西安Rubyists的一员报名当了教练(由于教练奇缺，而我们Rubyist成员大多都去北京参加RubyConf了，所以我作为Rubyists里面的菜鸟报名当教练了，去了发现除我外，其他教练都是TW员工,顿时汗颜)。</p>

<!-- more -->


<p>每个教练指导2-3个学员，人员的分配通过软件随机组合，没想到竟然给我分了3个！不过幸好有指导教程，指导起来便没有无从下手的感觉，由于报名的学员几乎都没接触过Rails,所以指导难度不是很大，大概从环境的配置到一个简单的web应用生成方面进行了指导，然后加上TW准备的几个Session演讲，一天也就过去了，临近结束，没想到竟然碰到同一个县城的老乡，真的太意外了。临走前还一起吃了个饭，聊了估计有差不多一个小时，然后匆忙的坐车回学校了，到学校门口天早已漆黑一片，感觉特别累，到教研室待到差不多11：00便回宿舍睡觉了。有时候真的在想，要是上班了那不得累趴下！这还什么事都没干就这么累。</p>

<p>不知不觉码字码了这么多，但感觉毫无重点，还是进入正题吧，不然就感觉文不对题了。</p>

<p>Vim的寄存器类型请通过<code>:help registers</code>查看，下面只介绍两种：</p>

<ol>
<li>数字寄存器</li>
<li>字母寄存器</li>
</ol>


<h2>1. 数字寄存器</h2>

<p>数字寄存器大致有10种，编号从0-9，并且都以<code>"</code>开头，通过<code>:reg</code>便可查看。其中<code>"0</code>保存上次<strong>复制(y)</strong>操作的文本，而<code>"1——"9</code>寄存器则保存最近9次<strong>删除</strong>的文本<strong>行</strong>,<code>"1</code>保存的是最近一次删除的内容，如果又有新的操作，则将1保存到2中，然后1保存最新内容。</p>

<h2>2. 字母寄存器</h2>

<p>字母寄存器从a-z或者A-Z,其中指定a-z会替换掉他们先前存储的内容，而A-Z则会在它们先前保存的内容中追加新内容。</p>

<p>一般paste可能都通过来操作，这仅粘贴0或1寄存器中的内容,要想粘贴内容其他寄存器的内容，则需通过<code>寄存器的名称+p</code>来操作。如将内容保存到a寄存器中，则可在normal模式下输入<code>"ayy</code>，将光标当前行内容存储在a寄存器中，粘贴便可通过<code>"ap</code>来操作。</p>

<p>寄存器可能平时用不上，一般在需要录制宏的时候才会用到。想要更深入的了解，还是<code>:help registers</code>看帮助文档吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop集群]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/22/hadoop-cluster-1/"/>
    <updated>2013-10-22T20:51:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/22/hadoop-cluster-1</id>
    <content type="html"><![CDATA[<p>最近开始研究起Hadoop,《Hadoop in Action》大概看了3章，然后开始着手搭建环境。</p>

<p>由于设备的受限，让老师给分了两台虚拟机（4G内存，20G硬盘，CentOS6.4），在上面开始搭建Hadoop集群，其中一台作为master,另一台作为slave。环境的搭建大概花了一天多的时间，主要有JDK的配置和SSH的配置，这两项已经是轻车熟路，所以很快便配置好。但是Hadoop才刚接触，所以配置起来速度慢点，没有一个绝对的参考资料，网上资料虽颇丰，但甄别对与错却需要一定时间，并且还要弄懂配置参数的意义。前后大致花了有半天时间。配置好后启动服务时却出错，google搜索了好久，也试过很多方法，但一直没解决。</p>

<!-- more -->


<p>问题主要出现在权限这块，因为采用root启动服务没问题，但是一般用户启动便提示创建<code>/var/logs/user</code>出错，权限不够，而我的logs目录已经在<code>conf/hadoop-env.sh</code>中设置为hadoop解压目录下的logs目录。最后实在没辙，便尝试重新配置。大致步骤也是按前边的进行，但是没想到最后竟然成功，真的太让人意外！通过jps能够看到master的namnode,jobtracker等的进程号，同时也能在slave上看到datanode,tasktracker的进程号。</p>

<p>安装好后，当然得找个实例测试下，hadoop的解压目录下自带有example，其中有个wordcount,便拿来测试了。</p>

<h3>创建本地测试文件</h3>

<pre><code>$mkdir ~/file
$cd ~/file
$echo "Hello World" &gt;&gt; ~/file1.txt
$echo "Hello Hadoop" &gt;&gt; ~/file2.txt
</code></pre>

<h3>在HDFS上创建Input目录</h3>

<pre><code>$hadoop fs -mkdir input
$hadoop fs -ls
</code></pre>

<h3>导入本地测试文件到HDFS中的input目录</h3>

<pre><code>$hadoop fs -put ~/file/file*.txt input
$hadoop fs -ls input
</code></pre>

<h3>运行wordcount程序</h3>

<p>以input为输入目录，output为输出目录</p>

<pre><code>$hadoop jar ~/hadoop-1.2.1/hadoop-examples-1.2.1.jar wordcount input output
</code></pre>

<h3>查看结果</h3>

<p>运行的结果会保存在output下的part-r-00000文件中，查看方法如下：</p>

<pre><code>$hadoop fs -cat output/part-r-00000
</code></pre>

<h3>后话</h3>

<p>近两天在看龙应台女士的《亲爱的安德烈》一书，全书以书信的方式来展开，通过她与儿子安德烈的对话，了解了香港、台湾及德国的一种生活方式，尤其是香港人民2005年的游行，不禁让我想到了中国的现状，顿时有种压抑的感觉，感觉中国人民一直在努力的奋斗，无非就是为了一份安宁的生活。但感觉就是这么一份安宁，却让太多的人为之奋斗一生而不得或千辛万苦才得，突然觉得这样的人生还有意义么？我目前期望的仅是今后能生活在技术圈中，而且不用再被生活所奴役，不愿再面对一群不懂技术而趾高气扬的人，已经听到身边不少人羡慕国企、银行、研究所等铁饭碗的单位，但我却丝毫没有兴趣，因为在我印象中，那些单位大多给人一种散漫感，其中充满了太多的勾心斗角，尔虞我诈，而我本身却非常厌恶这些，真的可以说让人作呕。呆在这样的环境工作一生，想想都觉得枯燥无味。希望明年能找到一份理想的工作，干自己喜欢的技术。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Putty SSH中文乱码]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/18/ssh-messy-code/"/>
    <updated>2013-10-18T10:59:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/18/ssh-messy-code</id>
    <content type="html"><![CDATA[<p>由于Fedora安装在教研室的台式机上，小组的活动在科协，每次去又免不了使用Linux环境，所以<strong>Putty</strong>便派上用场了。Putty作为Windows下的SSH工具，确实很方便，解决了很多不必要的麻烦，但是发现在使用的时候，中文显示乱码。求救Google的时候到了，网上一搜，真的是一大堆，随便查看了一篇博客，照着试了一下便解决。方法如下：</p>

<blockquote><p>windows->Appearance->Translation,在其中将字体改为UTF-8便没问题。</p></blockquote>

<p>问题确实能解决，但是发现不能保存设置，每次打开Putty时都需要重新设置，这点有待改进,不知道是我安装的putty版本过低还是其他的缘故。在分享中成长，在成长中分享，大胆的分享吧，Don&rsquo;t be shy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些感想]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/15/some-feelings/"/>
    <updated>2013-10-15T19:55:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/15/some-feelings</id>
    <content type="html"><![CDATA[<p>如果要评价自己的话，那么我会将自己归为乐于分享的一类，不管是技术还是工具，亦或代码。平时也都关注一些科技新闻和博客，每当发现不错的信息时，都会想着第一时间将其分享给身边的朋友。</p>

<p>分享过的工具中记忆比较深的当属Git，GitHub，Evernote和Vim了，系统方面则有Linux，编程方面则有Ruby。虽然可能最终用的人不是很多，但起码他们脑海中已经有了这个词，我觉得这也就够了，毕竟大部分人还是守旧派，不愿接触新鲜事物。但自己这颗乐于分享的心却从未动摇过，只要有好东西，绝对第一时间分享。但总会有那么一些人会对我的举措有误解，认为我是一个喜欢炫耀的人，推荐给大家一些他们闻所未闻的新鲜事物是为了证明我的牛，我只能一笑置之，也不想多做辩解。因为解释过多，可能又会有人说“解释是为了更好的掩饰”，所以沉默是最好的回应。</p>

<!-- more -->


<p>我只想在自己技术和知识面的提升时，同时也能够帮助身边的人有所进步。只想带给大家正能量，因为我一直觉得一个人不管多有才，如果不能影响身边的人，那么他的存在价值便为0，一个人于他人无益，便只能说他白活了。最后只想说一句：</p>

<blockquote><p>走自己的路，让他人去说吧！</p></blockquote>

<p>如果你是一个喜欢码字的人，并且觉得jekyll或者Octopress难以配置的话，那么Ghost也许是不错的选择，并且支持Markdown的格式。具体介绍，请参考<a href="http://ghost.org/">Ghost官网</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux硬链接与软链接]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/10/linux-hard-link-vs-soft-link/"/>
    <updated>2013-10-10T09:42:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/10/linux-hard-link-vs-soft-link</id>
    <content type="html"><![CDATA[<p>链接的概念其实不仅限在Linux中，在类Unix和Windows中也存在，只是网上资料大多都讨论的是类Unix的链接。下面主要对所了解的类Unix下的链接谈谈自己的认识。</p>

<h3>链接存在的目的</h3>

<p>链接的出现主要是为了解决系统中文件的共享，同时有其他附加的好处：隐藏真实文件路径、增加权限安全及节省存储。简单的举例说明：</p>

<p>Linux中有7种run level(0-6),其中0代表关机，1代表单用户模式(用于系统维护，禁止远程登陆),2代表多用户状态(不支持NFS)，3代表完全的多用户模式，4系统保留(未使用),5代表X11模式(GUI模式)，6则代表重启。</p>

<p>这7种模式分别对应/etc/rc.d/rcN.d目录(N指0-6之间的数字)，存储的是每种启动模式下要启动的程序，但实际的程序其实存储在/etc/rc.d/init.d目录中，/etc/rc.d/rcN.d中都是链接而已，链接到/etc/rc.d/init.d目录中对应的程序(这样做的目的是为了管理上的方便，试想一下，如果有多个runlevel包含同一个程序，需要对这个程序的启动脚本进行修改时，只需更改/etc/rc.d/init.d中的实际文件，而不需要改动/etc/rc.d/rcN.d)。</p>

<h3>链接的分类</h3>

<p>链接分为两种：硬链接(hard link)与阮链接(soft link)。谈链接就不得不谈inode，所以先简单地介绍下inode。</p>

<!-- more -->


<p><strong>inode</strong></p>

<p>类unix中，文件被分为两部分：用户数据(user data)和元数据(metadata)。用户数据，即文件数据块(data block),数据块是记录文件真实内容的地方，而元数据则是记录文件的附加属性，如文件大小、创建时间、所有者等信息。而inode则负责存储这些元数据，inode确切的说是一个数据结构，包含了文件的所有信息(文件名除外)。inode包含的详细信息为：</p>

<ul>
<li>Inode number</li>
<li>Access Control List(ACL)</li>
<li>Extended attribute</li>
<li>Direct/indirect disk blocks</li>
<li>Number of blocks</li>
<li>File access, change and modification time</li>
<li>File deletion time</li>
<li>File generation number</li>
<li>File size</li>
<li>File type</li>
<li>Group</li>
<li>Number of links</li>
<li>Owner</li>
<li>Permissions</li>
<li>Status flags</li>
</ul>


<p>通过<code>ls -i</code>或者<code>stat filename</code>可查询文件对应的inode信息</p>

<p>文件新建时，内核会分配一个inode,每个文件的inode号唯一，可以简单地将其理解成指针，指向对应文件的具体的存储位置。访问文件时，inode会被复制到内存，然后根据inode将对应的文件复制到内存。</p>

<p><strong>硬链接</strong></p>

<p><img src="http://pic.yupoo.com/xautjzd/DdZo1Za8/medish.jpg" alt="" /></p>

<p>如图，硬链接其实就是在现有文件上添加了一个别名，他们有共同的inode,但硬链接有以下不足：</p>

<ol>
<li>不能跨文件系统(inode号仅在同一文件系统下唯一，当挂载多个文件系统后，便可能会出现inode号重复的现象，所以不能跨文件系统)</li>
<li>只能针对文件创建硬链接，不能对目录创建</li>
</ol>


<p>每个inode都有一个链接计数器,默认文件的inode计数器值为1,每当创建一个硬链接，计数器值便加1，而删除文件时，其实是计数器值减1，只有当计数器为0时，文件才从物理磁盘上删除。</p>

<p>下面看一个实例：</p>

<pre><code>265092 -rw-rw-r--   2 fedora fedora         0 Oct 10 14:16 test
265092 -rw-rw-r--   2 fedora fedora         0 Oct 10 14:16 testdl
265164 lrwxrwxrwx   1 fedora fedora         4 Oct 10 14:18 testsl -&gt; test
</code></pre>

<p>其中test为新建的测试文件，testdl是在test上建立的硬链接，testsl是在test之上的软链接。可以发现test与testdl的inode号相同，而test与testsl的inode号则不同，在创建了硬链接之后，test与testdl的计数器变成2了。</p>

<p><strong>软链接</strong></p>

<p>软链接(也称符号链接 symbol link)刚好弥补了硬链接的不足，不存在文件系统的限制，同时也可以创建指向目录的符号链接。所以现在广泛使用的一般是软链接，它具有更强的灵活性。但它同时也具有硬链接没有的缺点，那就是：</p>

<ol>
<li>软链接包含原有文件的路径信息，一旦原文件移到其他路径下，再访问软链接，便找不到了，硬链接则无影响。</li>
<li>系统会为软链接分配额外的空间用于建立新的inode并保存原文件的路径</li>
</ol>


<h3>软链接与硬链接的区别</h3>

<ol>
<li>硬链接与原文件inode号相同，表明他们是同一个文件；而软链接与原文件inode号不同，说明他们是两个不同的文件。(上图便可看出)</li>
<li>文件属性上软链接明确标明了是链接文件，而硬链接则没有，因为在本质上硬链接与原文件是完全平等的关系。</li>
<li>链接计数器不同，软链接的计数器不会增加。</li>
<li>文件大小不同，硬链接文件显示的大小与原文件相同，而软链接则显示的大小与原文件不同。</li>
</ol>


<h3>参考文档</h3>

<ol>
<li><a href="http://www.cnblogs.com/ovliverlin/archive/2008/10/28/1321521.html">http://www.cnblogs.com/ovliverlin/archive/2008/10/28/1321521.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">http://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下锐捷客户端上网]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/09/surf-internet-under-linux-about-ruijie/"/>
    <updated>2013-10-09T17:17:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/09/surf-internet-under-linux-about-ruijie</id>
    <content type="html"><![CDATA[<p>自己虽然一直用的校园网，但是由于教研室这块位置比较特殊，不需要使用锐捷客户端认证，但其他地方一般都需要。所以今早有个朋友在笔记本上安装了Ubuntu，但是无法通过锐捷web方式认证，下载的锐捷Linux版客户端安装后也无法上网，所以这方面我也不熟悉，只能求助Google了。由于众多高校的网络都是使用锐捷的这一套，所以大同小异，这方面的资料也不少，Google搜索很快便找到了解决方法，用华科的一个客户端即可，下载地址：<a href="http://code.google.com/p/mentohust/">http://code.google.com/p/mentohust/</a></p>

<p>下载后，切换到下载的目录，然后运行<code>sudo dpkg -i 'your deb packagename'</code>即可，安装过程中，一步一步按照其步骤输入相应信息即可。安装完成后，会将配置的信息存储在<code>/etc/mentohust.conf</code>文件中，也可进行修改。在安装的过程中，如果采用DHCP方式，在选择时应该注意，选择1或者2，千万别选择3，否则上不了网。各选项的含义是：</p>

<p>-d DHCP方式：0（不使用） 1（二次认证）2（认证后）3（认证前）</p>

<p>关于mentohust的详细参数解释，请参考<a href="http://code.google.com/p/mentohust/wiki/Parameter">官网wiki</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fedora下使用sudo]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/08/use-sudo-in-fedora/"/>
    <updated>2013-10-08T15:11:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/08/use-sudo-in-fedora</id>
    <content type="html"><![CDATA[<p>Linux下日常操作使用一般用户权限即可，但是往往有一些操作需要用到root权限，如服务的启动、软件的安装等，直接转到root下进行操作可不是一个好习惯，比较稳妥的方式就是使用sudo进行操作。首先检查系统是否已经安装<code>sudo</code>,接下来需要在<code>/etc/sudoers</code>文件下进行配置相应的权限。</p>

<p>在<code>root    ALL=(ALL)   ALL</code>这行下面添加<code>username ALL=(ALL) NOPASSWD:ALL</code>即可。其中<code>username</code>为要使用sudo的用户，并且每次使用sudo时不需要输入root密码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[梦想]]></title>
    <link href="http://xautjzd.github.io/blog/2013/10/01/whats-my-dream/"/>
    <updated>2013-10-01T22:48:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/10/01/whats-my-dream</id>
    <content type="html"><![CDATA[<p>你要搞清楚自己人生的剧本——不是你父母的续集，不是你子女的前传，更不是你朋友的外篇，对待生命你不妨大胆冒险一点，因为好歹你要失去它。如果这世界上真有奇迹，那只是努力的另一个名字，生命中最难的阶段不是没有人懂你，而是你不懂你自己。——尼采</p>

<p>当读到这段话时，我陷入了沉思，不禁想：人生短短几十年，生命的1/3差不多已悄然而逝，在这1/3的年华中自己收获了什么，失去了什么。我想得到的可能就是人们眼中所谓的专业知识，比一般人士更了解计算机而已，同时可能收获的是思考问题和解决问题的能力。而失去的确是童年该有的肆无忌惮的玩耍，天马行空的想法，取而代之的是那铜墙铁壁似的教室的囚禁，被教导做个父母、老师眼中的乖孩子，死记硬背那些该死的口诀表和公式。</p>

<!-- more -->


<p>熟不知imagination is more important than knowledge。如今的我们早已丧失了孩童时代的那种超凡想象力，它们早已被所学的知识所囚禁，想要挣脱却不得。同时我们变得没有梦想，确切的说是终极梦想。仅有的只是阶段性梦想，小学开始便想着如何努力学习上重点初中，中学三年该如何发奋上个理想的高中，高中三年挥洒着汗与泪争取上个令人满意的大学，上了大学便开始思索如何学习才能毕业后找个好工作。找着工作后可能便又想着买房结婚的事了。</p>

<p>我们有自己的终极梦想么？我们是否一直为之做不懈的努力呢？我扪心自问，我没有一个从小到现在一直在坚持的梦，唯一有的只是阶段性的，每当完成时，不禁窃喜。不过随着时间的流逝，这种成就感也便逐渐消散，直至不复存在。所以难免会有迷茫，有时会突然觉得空虚，便开始质疑生活的真谛、存在的意义。心若空了，便干什么都会觉得没劲，不过这种日子往往是短暂的。因为一直都在忙碌，忙着学习专业知识，以求跟上时代的步伐，跟上大流，毕竟计算机更新换代太快，要学的实在太多。正是忙着学习，可能忘了反思，忘了生活的意义，这种学习与生活混为一体的日子真是我想要的么？我想我无法回答。</p>

<p>以前没有梦想，是因为接触的事物当中没有一件是我心动的，都不足以支撑我为之拼搏。现在我想我找到了，那就是成为一名Geek,虽然还非常遥远，但是我却能始终朝着那一方向努力。每次看《Unix网络编程》和《Unix环境高级编程》时，总会为那些非凡的设计所折服;学习Ruby时，会被其亲切自然的语法所吸引;使用Linux和Vim时，总能感觉到其魅力;当了解了某一原理时，便不胜欣喜。I love it.</p>

<p>以前之所以没有一个为之努力奋斗的梦想，我想是因为接触的不够多的缘故吧。所以小孩子应该重点拓宽他们的知识面，让他们找准自己的兴趣所在，而不是一味求深，还给他们一片自由的空间吧！中国的教育何时能有质的提升？希望在有生之年能够看到。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dead Code]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/29/dead-code/"/>
    <updated>2013-09-29T10:09:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/29/dead-code</id>
    <content type="html"><![CDATA[<p>今天在网上看到腾讯的一个实习生招聘题，里面提到了dead code，便上wikipedia查了下，解释如下：</p>

<p>在计算机编程中，dead code是指那些被执行但执行结果在其他地方没有用到的代码。dead code的执行耗费cpu时间但是结果无用。</p>

<p>dead code的执行结果没用也就罢了，但它还可能同时导致异常或影响某些全局状态，所以移除这些dead code可能会改变程序的输出，并且排除那些意想不到的bugs。</p>

<p>参考文档：</p>

<p><a href="http://en.wikipedia.org/wiki/Dead_code">http://en.wikipedia.org/wiki/Dead_code</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机启动过程]]></title>
    <link href="http://xautjzd.github.io/blog/2013/09/26/boot-process/"/>
    <updated>2013-09-26T18:48:00+08:00</updated>
    <id>http://xautjzd.github.io/blog/2013/09/26/boot-process</id>
    <content type="html"><![CDATA[<p>计算机启动过程的详细介绍请参考阮一峰老师的两篇博文：</p>

<ol>
<li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">http://www.ruanyifeng.com/blog/2013/02/booting.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html">http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html</a></li>
</ol>


<p>写的非常通俗易懂，真的很佩服阮老师的文笔，有时候自己写的博客自己都有点目不忍视，更何况别人呢。要达到这样的水平真的还有好长的路要走。加油吧</p>
]]></content>
  </entry>
  
</feed>
